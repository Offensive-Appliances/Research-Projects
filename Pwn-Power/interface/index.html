<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PwnPower</title>
    
    
    <style>body{background-color:#222222;color:#fff;margin:0;font-family:'Courier New',Courier,monospace;font-weight:700;font-size:16px} 
    
    .toggle-button {
            background-color: #444;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 8px;
            cursor: pointer;
            border-radius: 20px;
            transition: background-color 0.3s ease;
            font-size: 15px;
        }

        .toggle-button:hover {
            background-color: #555;
        }

        .toggle-button.green {
            background-color: #79101098 !important;
        }

        /* modern input styles for forms inside cards */
        .card form {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .card form input[type="text"],
        .card form input[type="password"],
        .card form input[type="url"],
        .card form input[type="file"] {
            width: 100%;
            padding: 10px 12px;
            background: #0f0f0f;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            color: #fff;
            font-weight: 500;
            font-family: 'Courier New', Courier, monospace;
            box-sizing: border-box;
        }

        /* Align buttons to the left edge of the card like titles */
        .card .toggle-button {
            margin: 8px 0 8px 0;
            align-self: flex-start;
        }
    
        .button-grid {
            display: flex;
            gap: 8px;
            justify-content: flex-start;
            align-items: center;
            margin-top: 10px;
        }

        .warning-text {
            display: inline-block;
            color: #ffffff;
            background-color: rgba(179, 23, 23, 0.15);
            border: 1px solid #b31717;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            margin: 10px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
            text-align: center;
            backdrop-filter: blur(4px);
            box-shadow: 0 2px 4px rgba(179, 23, 23, 0.1);
            transition: all 0.3s ease;
        }

        .warning-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }

        .warning-text::before {
            content: "";
            margin-right: 6px;
        }

        .warning-text:hover {
            background-color: rgba(179, 23, 23, 0.25);
            box-shadow: 0 4px 8px rgba(179, 23, 23, 0.2);
            transform: translateY(-1px);
        }

        .highlight, .highlighted {
            outline: 1px solid #b31717;
            background-color: transparent;
        }
        .client-selected,
        .highlight,
        .highlighted {
            background-color: rgba(94, 94, 94, 0.15) !important;
            outline: 1px solid #b31717;
        }
    

    header {
        background-color: #141414;
        padding: 22px 20px;
        text-align: center;
        box-shadow: 0 2px 10px rgba(0,0,0,0.25);
        position: relative;
        border-bottom: 1px solid rgba(255,255,255,0.05);
        backdrop-filter: blur(5px);
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .section {
        max-width: 600px;
        width: 90%;
        margin: 20px auto;
        background-color: #1a1a1a;
        border-radius: 8px;
        overflow: hidden;
        box-sizing: border-box;
    }
    h1 {
        font-size: 26px;
        margin-bottom: 0px;
    }
    h3 {
        margin-top: -20px;
        font-size: 18px;
    }
    .section-title {
        cursor: pointer;
        padding: 10px;
        border-bottom: 1px solid rgba(255,255,255,.3);
        text-align: center;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0;
    }
    .section-content {
        padding: 5px;
        transition: max-height .3s ease,padding .3s ease;
        max-height: 0;
        overflow: hidden;
        box-sizing: border-box;
    }
    .section.expanded .section-content {
        max-height: none;
    }
    .section.expanded .section-title .arrow-down {
        transform: rotate(180deg);
    }
    h2 {
        color: #fff;
        margin: 0;
        font-size: 22px;
    }
    .center-text {
        text-align: center;
        font-size: 16px;
        color: #fff;
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
    }
    .arrow-down {
        transition: transform .3s ease-out;
    }
    .expanded .arrow-down {
        transform: rotate(180deg);
    }
    .separator {
        margin-top: 10px;
        border-top: 1px solid rgba(255,255,255,.3);
    }
    .chart-container {
        position: relative;
        max-width: 800px;
        margin: 40px auto;
        padding-left: 50px;
        height: 300px;
        display: flex;
    }
    .y-axis {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 30px;
        display: flex;
        flex-direction: column-reverse;
        justify-content: space-between;
        align-items: flex-end;
        padding-right: 5px;
        z-index: 2;
    }
    .chart-bars {
        flex: 1;
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        position: relative;
        margin-bottom: 30px;
        z-index: 1;
        width: 100%;
    }
    .x-axis {
        position: absolute;
        bottom: -30px;
        left: 0;
        right: 0;
        height: 20px;
        display: flex;
        justify-content: space-around;
    }
    .chart-bar {
        width: var(--bar-width, 30px);
        background: #b31717;
        position: relative;
        transition: height 0.5s ease;
        margin: 0 1px;
        min-width: 20px;
    }
    .chart-bar-label {
        position: absolute;
        bottom: -20px;
        width: 100%;
        text-align: center;
        font-size: 14px;
        color: #fff;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
    }
    .chart-bar-value {
        display: none;
    }
    .wifi-table, .handshake-table, .client-table {
        border-collapse: collapse;
        margin-bottom: 20px;
        overflow-x: auto;
    }

    /* responsive table wrappers */
    .table-wrap {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }
    @media (max-width: 768px) {
        .wifi-table, .handshake-table, .client-table {
            display: block;
            width: max-content;
        }
        .table-wrap {
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
        }
    }

    .card-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
        width: 100%;
        box-sizing: border-box;
    }
    .card {
        background: #1a1a1a;
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .card h4 {
        margin: 0 0 6px 0;
        font-size: 16px;
    }
    .download-card {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .muted {
        color: #aaa;
        font-size: 12px;
    }


/* base cell styles */
.wifi-table td,
.wifi-table th,
.handshake-table td,
.handshake-table th,
.client-table td {
    padding: 8px;
    text-align: left;
    border: 1px solid rgba(48, 48, 48, 0.3);
    font-size: 15px;
}

/* attack table specific */
#wifi-attack-table-body tr {
    cursor: pointer;
    background-color: rgba(32, 32, 32, 0.3);
}

#wifi-attack-table-body tr:hover {
    background-color: rgba(179,23,23,0.1);
}

/* client table overrides */
.client-table {
    background-color: rgba(48, 48, 48, 0.3);
    margin: 4px 0 8px 0;
    table-layout: fixed;
    width: 100%;
    border-collapse: collapse;
    border-top: 1px solid rgba(255,255,255,0.3);
}

.client-table td {
    border-left: none;
    border-right: none;
    max-width: none;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    word-break: keep-all;
    color: #fff;
    background-color: rgba(48, 48, 48, 0.3);
    padding: 8px;
    font-size: 15px;
}

.client-table tr {
    border-bottom: 1px solid rgba(255,255,255,0.3);
}

.client-table tr:last-child {
    border-bottom: none;
}

.client-selected {
    background-color: rgba(94, 94, 94, 0.15) !important;
    outline: 1px solid #b31717;
}

/* vertical desktop media query */
@media (min-width: 769px) and (max-width: 1199px) {
    .section {
        max-width: 800px;
        width: 95%;
        margin: 20px auto;
        padding: 0 15px;
    }
    
    .wifi-table, 
    .handshake-table {
        width: 100%;
        table-layout: auto;
        display: table;
        margin: 0 auto;
    }
    .chart-container {
        max-width: 558px;
    }
    .client-table {
        width: 100%;
    }
    
    .wifi-table th {
        padding: 12px 15px;
    }
    
    .wifi-table td {
        padding: 10px 15px;
    }
    .pie-container {
        left: 158px;
    }
    
    .chart-bar {
        width: 25px;
        margin: 0;
    }
}

/* updated desktop media query */
@media (min-width: 1200px) {
    .section {
        max-width: 1200px;
        width: 100%;
        margin: 20px auto;
        padding: 0 20px;
    }
    
    .charts-wrapper {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 20px;
        margin: 20px 0;
        padding: 0;
    }

    .chart-section {
        flex: 0 0 50%;
    }

    .pie-section {
        flex: 0 0 35%;
    }

    .chart-container {
        flex: 0 0 50%;
        margin: 0;
        padding-left: 50px;
        padding-right: 10px;
        max-width: 465px;
        margin-top: 20px;
        height: 250px; /* Added fixed height to match pie-container */
    }
    .pie-container {
        flex: 0 0 35%;
        margin: 0;
        max-width: none;
        height: 250px;
        right: 159px;
        margin-left: 60px;
        margin-top: 20px; /* Added this to match chart-container */
    }

    .pie-chart {
        width: 180px;
        height: 180px;
    }

    .pie-legend {
        position: relative;
        right: auto;
        top: auto;
        transform: none;
        margin-left: 15px;
        padding: 10px;
    }

    .chart-bars {
        margin-right: 10px;
    }

    .y-axis {
        left: 5px;
    }
    
    .pie-container {
        flex: 0 0 40%;
        margin: 0;
        max-width: none;
    }
    
    .pie-legend {
        position: relative;
        right: auto;
        top: auto;
        transform: none;
        margin-left: 20px;
    }
    
    .wifi-table, 
    .handshake-table {
        width: 100%;
        table-layout: auto;
        display: table;
        margin: 0 auto;
    }
    
    .client-table {
        width: 100%;
    }
    
    .wifi-table th {
        padding: 12px 15px;
    }
    
    .wifi-table td {
        padding: 10px 15px;
    }
    
    .chart-bar {
        width: 25px;
        margin: 0;
    }
}

/* mobile-specific media query */
@media (max-width: 768px) {
    .section {
        width: 95%;
        max-width: none;
        margin: 10px auto;
    }
    
    .wifi-table td, 
    .wifi-table th,
    .client-table td {
        padding: 6px;
        font-size: 12px;
    }
    
    .client-table {
        width: 100%;
    }
    
    /* make MAC addresses more visible */
    td:nth-child(2) {
        font-family: monospace;
        color: #b31717;
    }
    
    .chart-container {
        padding-left: 40px;
        margin: 20px auto;
    }
    
    .y-axis {
        font-size: 10px;
    }
    
    .chart-bar {
        width: 20px;
        margin: 0;
        min-width: 20px;
    }
    
    .chart-bar-label {
        font-size: 10px;
        bottom: -15px;
    }
    
    .chart-bars::before {
        left: -25px;
    }
    
    .y-axis div {
        right: -30px;
        font-size: 10px;
        width: 25px;
    }

    .chart-bars {
        justify-content: flex-start;
        padding: 3 10px;
        margin-left: 20px;
    }
    
    .chart-bar {
        min-width: 30px;
        margin: 0 1px;
    }
    
    .x-axis {
        width: 100%;
        padding: 0 10px;
    }
}

/* add grid lines */
.chart-bars::before {
    content: '';
    position: absolute;
    top: 0;
    left: -30px;
    right: 10px;
    bottom: 0;
    background: linear-gradient(to top, 
        rgba(255, 255, 255, 0.7) 1px, 
        transparent 1px
    );
    background-size: 100% calc(100% / var(--y-steps));
    z-index: 0;
}

.y-axis div {
    position: relative;
    width: 100%;
    padding-right: 55px;
    right: -35px;
    width: 30px;
}

/* y-axis adjustments */
.y-axis div {
    right: -35px;
    padding-right: 15px;
    text-align: right;
}

/* base bar styles */
.chart-bar {
    flex-shrink: 0;
}

/* y-axis vertical line */
.y-axis::after {
    content: '';
    position: absolute;
    right: -43px;
    top: 0;
    bottom: 0;
    width: 1px;
    background: rgba(255, 255, 255, 0.7) 1px;
}

/* adjust label positioning */
.y-axis div {
    right: 35px;
    padding-right: -15px;
    text-align: right;
}

/* Pie chart styles */
.pie-container {
    position: relative;
    width: 100%;
    max-width: 300px;
    height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.pie-chart {
    width: 200px;
    height: 200px;
    border-radius: 50%;
    position: relative;
    background:#1a1a1a;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    overflow: hidden;
}

.pie-chart::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60%;
    height: 60%;
    background-color: #1a1a1a;
    border-radius: 50%;
    z-index: 2;
}

.pie-slice {
    position: absolute;
    width: 100%;
    height: 100%;
    transform-origin: center;
    transition: transform 0.3s ease, filter 0.3s ease;
    clip-path: none;
}

.pie-slice:hover {
    transform: scale(1.05);
    filter: brightness(1.2);
    z-index: 2;
}

.pie-slice:hover::after {
    opacity: 1;
}

.pie-slice::after {
    content: attr(data-percentage) '%';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    color: #0c0c0c;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    transition: opacity 0.3s ease;
    pointer-events: none;
    z-index: 3;
}

.pie-legend {
    position: absolute;
    right: -180px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 15px;
    background: rgba(32, 32, 32, 0.4);
    padding: 15px;
    border-radius: 8px;
    min-width: 160px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #fff;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.legend-color {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

@media (max-width: 768px) {
    .pie-container {
        flex-direction: column;
        height: auto;
        padding: 20px 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        position: relative;
        right: auto;
        left: auto;
    }
    
    .pie-legend {
        position: relative;
        right: 0;
        top: 20px;
        transform: none;
        margin-top: 20px;
        margin-bottom: 47px;
        width: 100%;
        text-align: center;
    }
    
    .pie-chart {
        width: 150px;
        height: 150px;
        margin: 0 auto;
    }

    .legend-item {
        justify-content: center;
    }
}


.chart-section h4, .pie-section h4 {
    margin-top: 10px;
    margin-bottom: 0;
    
}

/* Popup overlay and container */
.popup-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
    z-index: 1000;
    animation: fadeIn 0.3s ease-out;
}

.popup-container {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(34, 34, 34, 0.95);
    border: 2px solid #b31717;
    border-radius: 8px;
    padding: 20px 40px;
    box-shadow: 0 0 20px rgba(179, 23, 23, 0.3);
    z-index: 1001;
    min-width: 300px;
    text-align: center;
    animation: slideIn 0.3s ease-out;
}

.popup-text {
    color: #ffffff;
    font-size: 17px;
    margin: 0;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.popup-icon {
    color: #b31717;
    font-size: 24px;
    margin-bottom: 10px;
}

.popup-progress {
    width: 100%;
    height: 4px;
    background: rgba(179, 23, 23, 0.2);
    margin-top: 15px;
    border-radius: 2px;
    overflow: hidden;
}

.popup-progress-bar {
    width: 100%;
    height: 100%;
    background: #b31717;
    animation: progressShrink 5s linear;
    transform-origin: left;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from {
        transform: translate(-50%, -60%);
        opacity: 0;
    }
    to {
        transform: translate(-50%, -50%);
        opacity: 1;
    }
}

@keyframes progressShrink {
    from { transform: scaleX(1); }
    to { transform: scaleX(0); }
}

/* Mobile responsiveness for popup */
@media (max-width: 768px) {
    .popup-container {
        width: 90%;
        max-width: 300px;
        padding: 15px 20px;
    }
    
    .popup-text {
        font-size: 14px;
    }
}

/* Mobile responsiveness for deauth status */
@media (max-width: 768px) {
    #deauth-status {
        margin: 8px auto;
    }
    
    #deauth-status span {
        display: inline-block;
        font-size: 0.8em !important;
    }
    
    #deauth-timer {
        margin-left: 4px !important;
    }
    
    .popup-overlay {
        z-index: 1000;
    }
    
    .popup-container {
        width: 85%;
        max-width: 280px;
        padding: 15px;
    }
    
    .popup-text {
        font-size: 14px;
    }
}

p.center-text, h4 {
    font-size: 22px;
}
    
    /* hamburger menu styles */
    .hamburger-menu {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        cursor: pointer;
    }
    
    .hamburger-icon {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        width: 30px;
        height: 21px;
    }
    
    .hamburger-icon span {
        display: block;
        height: 3px;
        width: 100%;
        background-color: white;
        border-radius: 3px;
        transition: all 0.3s ease;
    }
    
    .menu-container {
        position: fixed;
        top: 0;
        right: -300px;
        width: 300px;
        height: 100%;
        background-color: #333;
        transition: right 0.3s ease;
        z-index: 999;
        padding-top: 60px;
        box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
        overflow-y: auto;
    }
    
    .menu-container.active {
        right: 0;
    }
    
    .menu-sections {
        display: flex;
        flex-direction: column;
        padding: 20px;
    }
    
    /* when menu is open, transform hamburger to X */
    .hamburger-icon.active span:nth-child(1) {
        transform: translateY(9px) rotate(45deg);
    }
    
    .hamburger-icon.active span:nth-child(2) {
        opacity: 0;
    }
    
    .hamburger-icon.active span:nth-child(3) {
        transform: translateY(-9px) rotate(-45deg);
    }
    
    /* overlay when menu is open */
    .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 998;
        display: none;
    }
    
    .overlay.active {
        display: block;
    }
    
    /* make sure the main content adjusts for mobile */
    .main-content {
        transition: margin-right 0.3s ease;
    }
    
    @media (max-width: 768px) {
        .main-content.shifted {
            margin-right: 0;
        }
    }

    .hamburger-menu {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        cursor: pointer;
    }
    
    .hamburger-icon {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        width: 30px;
        height: 21px;
    }
    
    .hamburger-icon span {
        display: block;
        height: 3px;
        width: 100%;
        background-color: white;
        border-radius: 3px;
        transition: all 0.3s ease;
    }
    
    .menu-container {
        position: fixed;
        top: 0;
        right: -300px;
        width: 300px;
        height: 100%;
        background-color: #333;
        transition: right 0.3s ease;
        z-index: 999;
        padding-top: 60px;
        box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
        overflow-y: auto;
    }
    
    .menu-container.active {
        right: 0;
    }
    
    .menu-sections {
        display: flex;
        flex-direction: column;
        padding: 20px;
    }
    
    /* when menu is open, transform hamburger to X */
    .hamburger-icon.active span:nth-child(1) {
        transform: translateY(9px) rotate(45deg);
    }
    
    .hamburger-icon.active span:nth-child(2) {
        opacity: 0;
    }
    
    .hamburger-icon.active span:nth-child(3) {
        transform: translateY(-9px) rotate(-45deg);
    }
    
    /* overlay when menu is open */
    .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 998;
        display: none;
    }
    
    .overlay.active {
        display: block;
    }
    
    /* make sure the main content adjusts for mobile */
    .main-content {
        transition: margin-right 0.3s ease;
    }
    
    @media (max-width: 768px) {
        .main-content.shifted {
            margin-right: 0;
        }
    }
</style>




</head><body>
    <div class="main-content">
        <header><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100" height="100" viewBox="0 0 100 100">
<image xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAIABJREFUeF7t3Qe0LEW1BuC+RlBURBQERIKCGVBAjCCgqCCCOQeygKKImDCAASSJGTAgKIIRMxgIikQlmjCjJEFBxRznra/e/GfV7Ttn0ul7Pbx3a62z5sxMd3X1/nf4966qngXN0javJLBgXo1m6WCapYDMMyVYCsj/Y0B68+zeuxpOp0rdaWez3GEB4p///Gdz61vfuvnZz37W/Oc//2n+/e9/l9der1deb3nLWza///3vm1vc4hbNzW52s/L3u9/9rhz/i1/8onnTm95Uul+wYEH5c56/K664ornb3e5WjtfPkUce2TzhCU9oLrzwwnLcNtts05xxxhnN+uuv35x55pnNE5/4xOa6665r/vjHPzZrrrnmQkNO3+37uPbaa5sbbrihufe97928/OUvb3beeefmE5/4RLPffvuVIXWFbOedDRhYz01+8pOfLMLeaaedph77b37zm2aZZZYpggfasssuWwC4/PLLmz/96U8FmMc97nHN0Ucf3eyyyy6LCPqYY45pbne72zXf/e53mx133LH561//2qyzzjoLgezNox/96OZrX/ta+fxFL3pR8773va+5+uqrmz//+c9Fqe51r3s1l156aXPCCSc0b3vb28oY+q0TYDrpZDbLcBM3v/nNiyZ7BQ7LyPtovM9898UvfrG54IILyo3feOONRehHHHHETPexjBkJLFhQLOjvf/97Ocf1HvKQhywyHN9///vfb371q1815513XrPXXnuV/gNIbXltUCjRW9/61ubXv/5189WvfrXZY489iqXvuuuuzWMe85hm6623LhbMerqwlsUFCDe14IYbbujRZgAQJu3W4m4CBC3729/+VjTzRz/6UbnhzTbbrHnUox5VNNC5P/7xj5u73vWuzT/+8Y/m+uuvb9Zdd93yHUFdeeWVM9e4/e1v39zhDndoLr744ubhD394sSbuyfk///nPi/BYEKtae+21h7osYOywww7NAx7wgAIkF7fGGms073nPe5qf/vSnzdOe9rTynf/XW2+9uq+p5Tr1iUN8TwHjxhtv7PG9hBih1hoOlIADmH/961/NRz7ykSIosYNLOeqoo8ZycWKDvlmJflgjnw8YQC+33HLle4K75pprmuc973nltbZe/ycO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" x="0" y="0" width="100" height="100"/>
</svg>
<div style="display:flex;align-items:center;gap:12px;">
  <h1 style="font-family: 'Courier New', Courier, monospace;margin:0;">PwnPower</h1>

</div>
<div style="display: inline-block; background: linear-gradient(135deg, #1a1a1a, #333); color: white; padding: 6px 6px; border-radius: 4px; font-size: 12px; font-weight: bold; letter-spacing: 0.5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); border: 1px solid #444; text-transform: uppercase; margin: 5px 0; font-family: 'Courier New', Courier, monospace;">
  
  Offensive Appliances Research
</div>
</header>
<main class="content-wrapper">

<section id="smartplug" class="section">
    <div class="section-title" onclick="toggleSection('smartplug')">
        <h2>Smart Plug</h2>
        <span class="arrow-down">&#9660;</span>
    </div>
    <div class="section-content">
        <div class="card-grid">
            <div class="card">
                <h4>GPIO Control</h4>
                <div class="muted">Control the smart plug (GPIO4). high = on, low = off</div>
                <div style="display:flex;align-items:center;gap:10px;margin-top:10px;">
                    <button id="plugOnBtn" class="toggle-button">Turn On</button>
                    <button id="plugOffBtn" class="toggle-button">Turn Off</button>
                    <div id="plugStatusBadge" style="display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:12px;background:#333;border:1px solid rgba(255,255,255,0.06);font-size:12px;font-weight:700;">
                        <span id="plugDot" style="width:10px;height:10px;border-radius:50%;background:#a00;display:inline-block;"></span>
                        <span id="plugText" style="color:#fff;">Unknown</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>


    <section id="deauth" class="section">
        <div class="section-title" onclick="toggleSection('deauth')">
            <h2>Wi-Fi Recon</h2>
            <span class="arrow-down">&#9660;</span>
        </div>
        <div class="section-content">
            <p class="center-text">Wireless Landscape</p>
            <div class="button-grid">
                <button id="scanButton" class="toggle-button" onclick="startScan()">Scan Networks</button>
                <button id="clearStorageButton" class="toggle-button" onclick="clearLocalStorage()">Clear Cache</button>
            </div>
            <div id="scanWarning" class="popup-overlay">
                <div class="popup-container">
                    <div class="popup-icon"></div>
                    <p class="popup-text">Scanning will disconnect you. Please refresh after ~15 seconds.</p>
                    <div class="popup-progress">
                        <div class="popup-progress-bar"></div>
                    </div>
                </div>
            </div>
            <div id="deauthWarning" class="popup-overlay">
                <div class="popup-container">
                    <div class="popup-icon"></div>
                    <p class="popup-text">Deauth will disconnect you for ~30 seconds</p>
                    <div class="popup-progress">
                        <div class="popup-progress-bar"></div>
                    </div>
                </div>
            </div>
            <div class="charts-wrapper">
                <div class="chart-section">
                    <div class="chart-container" id="chart-container">
                        <div class="y-axis">
                            <!-- dynamic y-axis labels -->
                        </div>
                        <div class="chart-bars" id="chartBars">
                            <!-- vertical bars -->
                            <div class="x-axis">
                                <!-- channel numbers -->
                            </div>
                        </div>
                        
                    </div>
                    <h4 style="text-align: center;">Channels</h4>
                </div>
                <div class="pie-section">
                    <div class="pie-container">
                        <div class="pie-chart" id="pieChart">
                            <!-- Pie slices will be added dynamically -->
                        </div>
                        <div class="pie-legend" id="pieLegend">
                            <!-- Legend items will be added dynamically -->
                        </div>
                        
                    </div>
                    <h4 style="text-align: center; position: relative; top: -2rem; left: -1rem;">Network Distribution</h4>
                </div>
            </div>
            
            <div class="separator"></div>
            <p class="center-text">Access Points</p>
            <div class="table-wrap">
            <table class="wifi-table">
                <thead>
                    <tr>
                        <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">SSID</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">MAC</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">Security</th>
                        <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">Channel</th>
                    </tr>
                </thead>
                <tbody id="deauthTableBody">
                    <!-- Table rows will be dynamically filled -->
                </tbody>
            </table>
            </div>
        </div>
    </section>





<section id="WiFi-Attacks" class="section">
    <div class="section-title" onclick="toggleSection('WiFi-Attacks')">
        <h2>Wi-Fi Attacks</h2>
        <span class="arrow-down">&#9660;</span>
    </div>
    <div class="section-content">
        <p class="center-text">Targets</p>
        <div class="warning-container">
            <p class="warning-text">Select A Target</p>
        </div>
        <div class="table-wrap">
        <table class="wifi-table">
            <thead>
                <tr>
                    <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">SSID</th>
                    <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">MAC</th>
                    <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">Security</th>
                    <th style="padding: 8px; text-align: left; border-bottom: 4px solid #b31717;">Channel</th>
                </tr>
            </thead>
            <tbody id="wifi-attack-table-body">
                <!-- Table rows will be dynamically added here -->
            </tbody>
        </table>
        </div>
    </div>
    <div class="example-text" style="display: none;">
        <p class="center-text">Attack + Capture Options</p>
        <div class="button-grid">
            <button id="button10" class="toggle-button" onclick="toggleButton(10)">Deauth</button>
            <button id="handshakeButton" class="toggle-button" style="display:none;" onclick="startHandshake()">Handshake</button>
            <button id="captureButton" class="toggle-button" style="display:none;" onclick="startGeneralCapture()">Capture</button>
            <div id="deauth-status" style="display: none; margin: 5px auto; text-align: center;">
                <span style="color: #b31717; font-size: 0.9em;">● DEAUTH ACTIVE</span>
                <span id="deauth-timer" style="color: #666; font-size: 0.8em; margin-left: 8px;">30s</span>
            </div>
            <div id="hs-status" style="display: none; margin: 5px auto; text-align: center;">
                <span style="color: #b31717; font-size: 0.9em;">● HANDSHAKE</span>
                <span id="hs-timer" style="color: #666; font-size: 0.8em; margin-left: 8px;">30s</span>
            </div>
            <div id="cap-status" style="display: none; margin: 5px auto; text-align: center;">
                <span style="color: #b31717; font-size: 0.9em;">● CAPTURE</span>
                <span id="cap-timer" style="color: #666; font-size: 0.8em; margin-left: 8px;">30s</span>
            </div>
            <br>
        </div>
        <div class="warning-container">
            <p class="warning-text">Target Still Selected</p>
        </div>
    </div>
    </section>

<section id="handshakes" class="section">
    <div class="section-title" onclick="toggleSection('handshakes')">
        <h2>Packet Captures</h2>
        <span class="arrow-down">&#9660;</span>
    </div>
    <div class="section-content">
        <div class="card-grid" id="handshakeCards"></div>
    </div>
</section>

<section id="firmware" class="section">
    <div class="section-title" onclick="toggleSection('firmware')">
        <h2>Firmware Update</h2>
        <span class="arrow-down">&#9660;</span>
    </div>
    <div class="section-content">
        <div class="card-grid">
            <!--
            <div class="card">
                <h4>Connect to Internet</h4>
                <div class="muted">Provide Wi‑Fi credentials for fetching updates</div>
                <form id="wifiConnectForm">
                    <input type="text" id="wifiSsid" placeholder="SSID">
                    <input type="password" id="wifiPass" placeholder="Password">
                    <div style="display:flex;align-items:center;gap:10px;">
                        <button type="submit" class="toggle-button">Connect</button>
                        <div id="wifiBadgeInline" style="display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:12px;background:#333;border:1px solid rgba(255,255,255,0.06);font-size:12px;font-weight:700;">
                            <span id="wifiDotInline" style="width:10px;height:10px;border-radius:50%;background:#a00;display:inline-block;"></span>
                        </div>
                    </div>
                </form>
                <div id="wifiStatusMsg" class="muted"></div>
            </div>
            -->
            <div class="card">
                <h4>Upload Firmware</h4>
                <div class="muted">Upload a .bin built for this device</div>
                <form id="otaUploadForm">
                    <input type="file" id="otaFile" accept=".bin" style="margin:8px 0;color:#fff;">
                    <button type="submit" class="toggle-button">Upload</button>
                </form>
                <div id="otaUploadMsg" class="muted"></div>
            </div>
            <!--
            <div class="card">
                <h4>Fetch From URL</h4>
                <div class="muted">Paste a direct firmware URL</div>
                <form id="otaFetchForm">
                    <input type="url" id="otaUrl" placeholder="https://.../firmware.bin" style="width:100%;margin:8px 0;">
                    <button type="submit" class="toggle-button">Fetch</button>
                </form>
                <div id="otaFetchMsg" class="muted"></div>
            </div>
            -->
        </div>
    </div>
</section>

<section id="credits" class="section">
    <div class="section-title" onclick='toggleSection("credits")'>
        <h2>Credits + Notes</h2>
        <span class="arrow-down">&#9660;</span>
    </div>
    <div class="section-content">
        <div class="card-grid">
            <div class="card">
                <h4>Credits</h4>
                <div class="muted">Developed by deki & Peaks</div>
                <div class="muted">PwnPower (ESP32C3)</div>
            </div>
            <div class="card">
                <h4>Warning</h4>
                <div class="muted">Educational purposes only</div>
                <div class="muted">Use at your own risk</div>
            </div>
        </div>
    </div>
</section>

</main>

<script>
let selectedRow = null;
let debugInterval = null;
let sizeAdjustmentInterval; 
let fetchInterval;
let isDeauthOpen = false;
let isWifiAttacksOpen = false;

let selectedClients = {}; // { apMac: [selectedClientMac1, selectedClientMac2, ...] }

function toggleSection(sectionId) {
    const section = document.getElementById(sectionId);
    const sectionContent = section.getElementsByClassName('section-content')[0];
    const arrow = section.getElementsByClassName('arrow-down')[0];

     const isExpanded = section.classList.contains('expanded');

    if (isExpanded) {
        section.classList.remove('expanded');
        sectionContent.style.maxHeight = '0';
        sectionContent.style.overflow = 'hidden';
        arrow.classList.remove('expanded');
        clearInterval(sizeAdjustmentInterval);

        if (sectionId === 'Settings') {
            clearInterval(fetchInterval);
            fetchInterval = null;
            isSettingsOpen = false;
        } else if (sectionId === 'deauth') {
            clearInterval(fetchInterval);
            fetchInterval = null;
            isDeauthOpen = false;
            const exampleText = document.querySelector('.example-text');
            if (exampleText) exampleText.style.display = 'none';
            const directButton = document.getElementById('button10');
            const handshakeButton = document.getElementById('handshakeButton');
            if (directButton) directButton.style.display = 'none';
            if (handshakeButton) handshakeButton.style.display = 'none';
        } else if (sectionId === 'WiFi-Attacks') {
            isWifiAttacksOpen = false;
            clearInterval(fetchInterval);
            fetchInterval = null;
            const exampleText = document.querySelector('.example-text');
            if (exampleText) exampleText.style.display = 'none';
            const directButton = document.getElementById('button10');
            const handshakeButton = document.getElementById('handshakeButton');
            if (directButton) directButton.style.display = 'none';
            if (handshakeButton) handshakeButton.style.display = 'none';
        }

    } else {
        section.classList.add('expanded');
        sectionContent.style.overflow = 'visible';
        sectionContent.style.maxHeight = sectionContent.scrollHeight + 'px';

        sizeAdjustmentInterval = setInterval(() => {
            if (section.classList.contains('expanded')) {
                sectionContent.style.maxHeight = sectionContent.scrollHeight + 'px';
            }
        }, 500);

        if (sectionId === 'light-color-setting') {
            fetchCurrentColor();
        } else if (sectionId === 'Settings') {
            if (!isSettingsOpen) {
                isSettingsOpen = true;
            }
        } else if (sectionId === 'deauth') {
            if (!isDeauthOpen) {
                isDeauthOpen = true;
            }
        } else if (sectionId === 'WiFi-Attacks') {
            if (!isWifiAttacksOpen) {
                isWifiAttacksOpen = true;
            }
        }
    }

    arrow.classList.toggle('expanded');
}


function updateWiFiAttackTable(newData) {
    const tableBody = document.getElementById('wifi-attack-table-body');
    if (!tableBody) return;

    // clear existing rows
    tableBody.innerHTML = '';

    // use the same createAPRowWithStations function
    newData.forEach(row => {
        createAPRowWithStations(row, tableBody);
    });
}



let selectedSSID = null;
let selectedMAC = null;

function toggleHighlight(row) {
    var table = row.closest('.wifi-table');
    var isWiFiAttackTable = table && table.querySelector('tbody').id === 'wifi-attack-table-body';
    var rows = table.querySelectorAll('tbody tr');
    
    if (isWiFiAttackTable) {
        // clear previous selections
        document.querySelectorAll('.client-selected').forEach(clientRow => {
            clientRow.classList.remove('client-selected');
        });
        selectedClients = {};
    }

    rows.forEach(function(tr) {
        if (tr !== row) {
            tr.classList.remove('highlight');
        }
    });
    
    row.classList.toggle('highlight');
    
    if (isWiFiAttackTable) {
        if (row.classList.contains('highlight')) {
            selectedSSID = row.cells[0].textContent.replace(/^[+-] /, '');
            selectedMAC = row.getAttribute('data-mac');
            
            // find the ap in our data to get its clients
            const selectedAP = globalNetworkData.find(ap => ap.MAC === selectedMAC);
            if (selectedAP && selectedAP.stations && Array.isArray(selectedAP.stations)) {
                // automatically select all clients except those with same MAC as AP
                selectedClients[selectedMAC] = selectedAP.stations
                    .filter(station => station.mac !== selectedMAC)
                    .map(station => station.mac);
                
                // highlight all client rows
                const nextRow = row.nextElementSibling;
                if (nextRow) {
                    const clientRows = nextRow.querySelectorAll('.client-row');
                    clientRows.forEach(clientRow => {
                        clientRow.classList.add('client-selected');
                    });
                }
            }
        } else {
            selectedSSID = null;
            selectedMAC = null;
            selectedClients = {};
        }

        // Show/hide attack options based on selection
        const exampleText = document.querySelector('.example-text');
        const isSel = row.classList.contains('highlight');
        if (exampleText) exampleText.style.display = isSel ? 'block' : 'none';

        const directButton = document.getElementById('button10');
        const handshakeButton = document.getElementById('handshakeButton');
        if (directButton) {
            directButton.style.display = isSel ? 'inline-block' : 'none';
            directButton.textContent = 'Deauth';
        }
        if (handshakeButton) {
            handshakeButton.style.display = isSel ? 'inline-block' : 'none';
        }
        const captureButton = document.getElementById('captureButton');
        if (captureButton) {
            captureButton.style.display = isSel ? 'inline-block' : 'none';
        }
    }
}

let currentButton = null; 
let buttonStates = {};
let attackInterval = null;
let deauthTimer = null;

function updateDeauthTimer(startTime) {
    const timeLeft = Math.max(0, 30 - Math.floor((Date.now() - startTime) / 1000));
    document.getElementById('deauth-timer').textContent = `${timeLeft}s`;
    if (timeLeft === 0) {
        clearInterval(deauthTimer);
        const deauthStatus = document.getElementById('deauth-status');
        if (deauthStatus) {
            deauthStatus.style.display = 'none';
        }
        // reset button state
        buttonStates[10] = false;
        const button = document.getElementById('button10');
        if (button) {
            button.classList.remove('green');
        }
        
        // Reset deauth active flag
        isDeauthActive = false;
        
        // After deauth completes, fetch cached results
        setTimeout(() => {
            console.log('Deauth completed, fetching cached results');
            fetchCachedResults();
        }, 2000); // Wait 2 seconds after deauth completes
    }
}

function toggleButton(buttonNumber) {
    if (buttonNumber !== 10) return;
    
    const button = document.getElementById('button10');
    const deauthStatus = document.getElementById('deauth-status');
    
    if (buttonStates[10]) {
        buttonStates[10] = false;
        button.classList.remove('green');
        deauthStatus.style.display = 'none';
        clearInterval(deauthTimer);
        
        // Set deauth inactive flag
        isDeauthActive = false;
        
        // Send request to stop attack
        if (selectedSSID && selectedMAC) {
            const payload = {
                ssid: selectedSSID,
                mac: selectedMAC,
                channel: "1", // Default channel if not found
                state: 'stopped'
            };

            // Find the selected AP to get its channel
            const selectedAP = globalNetworkData.find(ap => ap.MAC === selectedMAC);
            if (selectedAP && selectedAP.Channel) {
                payload.channel = selectedAP.Channel.toString();
            }

            // automatically include all clients associated with this ap
            if (selectedAP.stations && Array.isArray(selectedAP.stations)) {
                // filter out any clients that have the same MAC as the AP (invalid)
                payload.sta = selectedAP.stations
                    .filter(station => station.mac !== selectedMAC)
                    .map(station => station.mac);  // extract all client macs
            }

            fetch('/start-attack', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                console.log('Attack stopped for button 10', data);
            })
            .catch(error => console.error('Error sending stop request:', error));
        }
        return;
    }

    // Toggle the selected button and set its state to active
    buttonStates[10] = true;
    button.classList.add('green');
    deauthStatus.style.display = 'block';
    
    // Set deauth active flag
    isDeauthActive = true;
    
    // Start the 30-second countdown timer
    const startTime = Date.now();
    updateDeauthTimer(startTime);
    deauthTimer = setInterval(() => updateDeauthTimer(startTime), 1000);

    // Find the selected AP to get its channel
    const selectedAP = globalNetworkData.find(ap => ap.MAC === selectedMAC);
    if (!selectedAP) {
        console.warn('Selected AP not found in data');
        buttonStates[10] = false;
        button.classList.remove('green');
        deauthStatus.style.display = 'none';
        clearInterval(deauthTimer);
        isDeauthActive = false;  // Reset flag if we can't find the AP
        return;
    }

    // Send attack request
    const payload = {
        ssid: selectedSSID,
        mac: selectedMAC,
        channel: selectedAP.Channel.toString(),
        state: 'started'
    };

    // automatically include all clients associated with this ap
    if (selectedAP.stations && Array.isArray(selectedAP.stations)) {
        // filter out any clients that have the same MAC as the AP (invalid)
        payload.sta = selectedAP.stations
            .filter(station => station.mac !== selectedMAC)
            .map(station => station.mac);  // extract all client macs
    }

    fetch('/start-attack', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Attack started:', data);
    })
    .catch(error => {
        console.error('Error sending attack request:', error);
        buttonStates[10] = false;
        button.classList.remove('green');
        deauthStatus.style.display = 'none';
        clearInterval(deauthTimer);
    });
}

// Add isDeauthActive flag
let isDeauthActive = false;
let isHandshakeActive = false;
let isCaptureActive = false;

// add these before fetchData function
let globalWifiData = []; // persistent wifi recon data
let globalAttackData = []; // persistent attack data

// Replace the global data declarations with:
let globalNetworkData = []; // single source of truth for all network data

// Load saved network data from localStorage on page load
document.addEventListener('DOMContentLoaded', function() {
    // Try to load saved network data
    const savedData = localStorage.getItem('networkData');
    if (savedData) {
        try {
            globalNetworkData = JSON.parse(savedData);
            console.log('Loaded saved network data:', globalNetworkData.length, 'APs');
            
            // Update UI with saved data
            updateReconTable();
            updateAttackTable();
            updateChart(globalNetworkData);
            
            // Fetch cached results from server immediately
            fetchCachedResults();
            // Load saved handshakes
            renderHandshakes();
        } catch (e) {
            console.error('Error parsing saved network data:', e);
            // If there's an error, start fresh
            fetchCachedResults();
            renderHandshakes();
        }
    } else {
        // No saved data, fetch cached results
        fetchCachedResults();
        renderHandshakes();
    }
});

// New function to fetch cached results without triggering a new scan
function fetchCachedResults() {
    console.log('Fetching cached scan results...');
    
    return fetch('/cached-scan')
        .then(response => response.json())
        .then(data => {
            if (data.rows && Array.isArray(data.rows) && data.rows.length > 0) {
                console.log('Received cached scan results:', data.rows.length, 'APs');
                
                // Clear existing data to avoid duplicates
                globalNetworkData = [];
                
                // Update our single source of truth
                data.rows.forEach(newRow => {
                    globalNetworkData.push(newRow);
                });
                
                // Save to localStorage
                try {
                    localStorage.setItem('networkData', JSON.stringify(globalNetworkData));
                } catch (e) {
                    console.error('Error saving network data to localStorage:', e);
                }
                
                // Update all relevant UI components
                updateReconTable();
                updateAttackTable();
                updateChart(globalNetworkData);
            } else {
                console.log('No cached results available, will trigger a new scan');
                // If no cached results, trigger a new scan
                // fetchData();
            }
        })
        .catch(error => {
            console.error('Error fetching cached results:', error);
            // If error, try a regular scan
            // fetchData();
        });
}

// Update the fetchData function:
function fetchData(sectionId) {
    // Skip scanning if deauth or handshake is active
    if (isDeauthActive || isHandshakeActive) {
        console.log('Skipping scan during active deauth');
        return;
    }

    console.log('Starting new WiFi scan...');
    const maxRetries = 3;
    const retryDelay = 1000;

    function fetchWithRetry(attempt = 0) {
        fetch('/scan')
            .then(response => response.json())
            .then(data => {
                if (data.rows && Array.isArray(data.rows)) {
                    // Update our single source of truth
                    data.rows.forEach(newRow => {
                        const existingIndex = globalNetworkData.findIndex(row => row.MAC === newRow.MAC);
                        if (existingIndex === -1) {
                            globalNetworkData.push(newRow);
                        } else {
                            // Preserve selection state when updating
                            const wasSelected = globalNetworkData[existingIndex].selected;
                            globalNetworkData[existingIndex] = {...newRow, selected: wasSelected};
                        }
                    });
                    
                    console.log('Network data updated:', globalNetworkData);
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem('networkData', JSON.stringify(globalNetworkData));
                    } catch (e) {
                        console.error('Error saving network data to localStorage:', e);
                    }
                    
                    // Update all relevant UI components
                    updateReconTable();
                    updateAttackTable();
                    updateChart(globalNetworkData);
                }
            })
            .catch(error => {
                console.error('Error fetching network data:', error);
                if (attempt < maxRetries) {
                    console.log(`Retrying in ${retryDelay}ms... (attempt ${attempt + 1}/${maxRetries})`);
                    setTimeout(() => fetchWithRetry(attempt + 1), retryDelay);
                }
            });
    }

    fetchWithRetry();
}

function startHandshake() {
    if (!selectedMAC) return;
    if (isDeauthActive || isHandshakeActive) return;
    const selectedAP = globalNetworkData.find(ap => ap.MAC === selectedMAC);
    if (!selectedAP || !selectedAP.Channel) return;
    isHandshakeActive = true;
    const hsStatus = document.getElementById('hs-status');
    const hsTimerEl = document.getElementById('hs-timer');
    if (hsStatus) hsStatus.style.display = 'block';
    const duration = 30;
    const start = Date.now();
    function tick() {
        const left = Math.max(0, duration - Math.floor((Date.now() - start) / 1000));
        if (hsTimerEl) hsTimerEl.textContent = left + 's';
        if (left === 0) {
            clearInterval(t);
            isHandshakeActive = false;
            if (hsStatus) hsStatus.style.display = 'none';
        }
    }
    tick();
    const t = setInterval(tick, 1000);
    const payload = {
        mac: selectedMAC,
        channel: selectedAP.Channel.toString(),
        duration: duration,
    };
    if (selectedClients[selectedMAC] && Array.isArray(selectedClients[selectedMAC])) {
        payload.sta = selectedClients[selectedMAC];
    }
    fetch('/handshake-capture', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
    .then(r => r.json())
    .then(d => {
        const entry = {
            type: 'handshake',
            ssid: selectedSSID || '',
            mac: selectedMAC,
            channel: selectedAP.Channel.toString(),
            eapol_count: (d && typeof d.eapol_count === 'number') ? d.eapol_count : 0,
            ts: Date.now()
        };
        try {
            const raw = localStorage.getItem('handshakes');
            const arr = raw ? JSON.parse(raw) : [];
            arr.push(entry);
            localStorage.setItem('handshakes', JSON.stringify(arr));
        } catch (e) {}
        renderHandshakes();
        fetchCachedResults();
    })
    .catch(e => {
        if (hsStatus) hsStatus.style.display = 'none';
        isHandshakeActive = false;
    });
}

function startGeneralCapture() {
    if (!selectedMAC) return;
    const selectedAP = globalNetworkData.find(ap => ap.MAC === selectedMAC);
    if (!selectedAP || !selectedAP.Channel) return;
    if (isDeauthActive || isHandshakeActive || isCaptureActive) return;
    const duration = 30;
    isCaptureActive = true;
    const capStatus = document.getElementById('cap-status');
    const capTimerEl = document.getElementById('cap-timer');
    if (capStatus) capStatus.style.display = 'block';
    const start = Date.now();
    function tick() {
        const left = Math.max(0, duration - Math.floor((Date.now() - start) / 1000));
        if (capTimerEl) capTimerEl.textContent = left + 's';
        if (left === 0) {
            clearInterval(t);
            isCaptureActive = false;
            if (capStatus) capStatus.style.display = 'none';
        }
    }
    tick();
    const t = setInterval(tick, 1000);
    const payload = { channel: selectedAP.Channel.toString(), duration: duration };
    fetch('/capture', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
    .then(r => r.json())
    .then(d => {
        try {
            const entry = {
                type: 'capture',
                ssid: selectedSSID || '',
                mac: selectedMAC,
                channel: selectedAP.Channel.toString(),
                ts: Date.now()
            };
            const raw = localStorage.getItem('handshakes');
            const arr = raw ? JSON.parse(raw) : [];
            arr.push(entry);
            localStorage.setItem('handshakes', JSON.stringify(arr));
        } catch (e) {}
        renderHandshakes();
        fetchCachedResults();
    })
    .catch(e => {});
}

// Split the table update into two functions that use the same data source
function updateReconTable() {
    const tableBody = document.getElementById('deauthTableBody');
    if (!tableBody) return;
    
    // Clear and rebuild table while preserving expansion states
    tableBody.innerHTML = '';
    globalNetworkData.forEach(row => {
        createAPRowWithStations(row, tableBody, false);
    });
}

function updateAttackTable() {
    const tableBody = document.getElementById('wifi-attack-table-body');
    if (!tableBody) return;
    
    // Clear and rebuild attack table
    tableBody.innerHTML = '';
    globalNetworkData.forEach(row => {
        createAPRowWithStations(row, tableBody, true);
    });
}

function updateChart(data) {
    const chartBars = document.getElementById('chartBars');
    const yAxis = document.querySelector('.y-axis');
    let xAxis = document.querySelector('.x-axis');
    if (!xAxis) {
        xAxis = document.createElement('div');
        xAxis.className = 'x-axis';
        chartBars.appendChild(xAxis);
    }

    // we need to clear these to prevent accumulation
    chartBars.innerHTML = '';
    yAxis.innerHTML = '';
    xAxis.innerHTML = '';

    // calculate max count for scaling
    const channelCounts = data.reduce((acc, row) => {
        const channel = row.Channel;
        acc[channel] = (acc[channel] || 0) + 1;
        return acc;
    }, {});
    
    const maxCount = Math.max(...Object.values(channelCounts), 1); // ensure at least 1 for division
    const yAxisSteps = Math.min(maxCount, 10);
    const stepSize = maxCount / yAxisSteps;
    const numBars = Object.keys(channelCounts).length;
    
    // calculate dynamic bar width based on container width and number of bars
    const containerWidth = chartBars.getBoundingClientRect().width || chartBars.offsetWidth;
    const minBarWidth = 20; // minimum width in pixels
    const maxBarWidth = 30; // maximum width in pixels
    const barWidth = Math.min(maxBarWidth, Math.max(minBarWidth, (containerWidth / numBars) - 2));
    
    // set css variable for grid lines and update bar width
    chartBars.style.setProperty('--y-steps', yAxisSteps);
    document.documentElement.style.setProperty('--bar-width', `${barWidth}px`);
    
    // create y-axis labels with exact positions
    for(let i = 0; i <= yAxisSteps; i++) {
        const label = document.createElement('div');
        const value = Math.round(i * stepSize);
        label.textContent = value;
        label.style.position = 'absolute';
        label.style.bottom = `${(i / yAxisSteps) * 100}%`;
        label.style.right = '-45px';
        label.style.marginRight = '0';
        yAxis.appendChild(label);
    }

    // create bars with background lines and dynamic width
    Object.entries(channelCounts).forEach(([channel, count]) => {
        const barHeight = (count / maxCount) * 100;
        
        const bar = document.createElement('div');
        bar.className = 'chart-bar';
        bar.style.height = `${barHeight}%`;
        bar.style.width = `${barWidth}px`;
        bar.innerHTML = `<div class="chart-bar-label">${channel}</div>`;
        chartBars.appendChild(bar);
    });

    // update pie chart with accumulated data
    const pieChart = document.getElementById('pieChart');
    const pieLegend = document.getElementById('pieLegend');
    
    if (!pieChart || !pieLegend) return;
    
    // clear pie chart containers
    pieChart.innerHTML = '';
    pieLegend.innerHTML = '';
    
    // calculate totals from accumulated data
    let totalAPs = data.length;
    let clientCount = 0;
    let unassociatedCount = 0;
    
    data.forEach(row => {
        if (row.stations && Array.isArray(row.stations)) {
            row.stations.forEach(station => {
                if (station.rssi && station.rssi <= -85) {
                    // clients with very weak signals are considered potentially unassociated
                    unassociatedCount++;
                } else {
                    clientCount++;
                }
            });
        }
    });
    
    const pieData = [
        { label: 'Access Points', value: totalAPs, color: '#800080' },
        { label: 'Connected Clients', value: clientCount, color: '#cd1c0e' },
        { label: 'Unassociated', value: unassociatedCount, color: '#2196F3' }
    ];
    
    const total = pieData.reduce((sum, item) => sum + item.value, 0);
    let cumulativeAngle = -90;
    
    pieData.forEach((slice) => {
        const percentage = slice.value / total;
        const angle = percentage * 360;
        
        const sliceElement = document.createElement('div');
        sliceElement.className = 'pie-slice';
        
        const startAngle = cumulativeAngle;
        
        sliceElement.style.background = `conic-gradient(
            from ${startAngle}deg,
            ${slice.color} 0deg,
            ${slice.color} ${angle}deg,
            transparent ${angle}deg
        )`;
        
        const clipPath = `conic-gradient(
            from ${startAngle}deg,
            ${slice.color} 0deg ${angle}deg,
            transparent ${angle}deg 360deg
        )`;
        
        sliceElement.style.webkitMaskImage = clipPath;
        sliceElement.style.maskImage = clipPath;
        
        sliceElement.dataset.percentage = Math.round(percentage * 100);
        sliceElement.title = `${slice.label}: ${slice.value} (${Math.round(percentage * 100)}%)`;
        
        pieChart.appendChild(sliceElement);
        
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        legendItem.innerHTML = `
            <div class="legend-color" style="background-color: ${slice.color}"></div>
            <span>${slice.label}: ${slice.value} (${Math.round(percentage * 100)}%)</span>
        `;
        pieLegend.appendChild(legendItem);
        
        cumulativeAngle += angle;
    });
}

// ensure chart resizes on window changes
window.addEventListener('resize', () => {
    if (Array.isArray(globalNetworkData) && globalNetworkData.length) {
        updateChart(globalNetworkData);
    }
});

// Global object to persist each AP's expanded state (keyed by MAC)
let apExpandedStates = {};

function updateTable() {
  const tableBody = document.getElementById('deauthTableBody');
  if (!tableBody) {
    console.error('no element found with id deauthtablebody');
    return;
  }
  
  // Get existing rows for comparison
  const existingRows = Array.from(tableBody.children);
  const existingMacs = new Set(existingRows.map(row => row.getAttribute('data-mac')));
  
  // Track processed MACs to handle removals
  const processedMacs = new Set();

  globalWifiData.forEach(row => {
    processedMacs.add(row.MAC);
    const existingRow = tableBody.querySelector(`tr[data-mac="${row.MAC}"]`);
    
    if (existingRow) {
      // Update existing row data if needed
      existingRow.cells[0].textContent = row.SSID || 'N/A';
      existingRow.cells[1].textContent = row.MAC || 'N/A';
      existingRow.cells[2].textContent = row.Security || 'N/A';
      existingRow.cells[3].textContent = row.Channel || 'N/A';
      
      // Update or create station rows while maintaining expansion state
      const isExpanded = apExpandedStates[row.MAC] === true;
      
      // Find existing station row if any
      const nextRow = existingRow.nextElementSibling;
      const existingStationRow = nextRow && !nextRow.hasAttribute('data-mac') ? nextRow : null;
      
      if (row.stations && row.stations.length > 0) {
        // Create or update station row
        const stationRow = existingStationRow || document.createElement('tr');
        const stationCell = existingStationRow ? existingStationRow.firstElementChild : document.createElement('td');
        stationCell.colSpan = 4;
        
        // Create client table
        const clientTable = document.createElement('table');
        clientTable.className = 'client-table';
        clientTable.style.width = '100%';
        
        row.stations.forEach(station => {
          const clientRow = document.createElement('tr');
          clientRow.className = 'client-row';
          
          const clientLabel = document.createElement('td');
          clientLabel.textContent = 'Client:';
          clientLabel.style.width = '15%';
          
          const macCell = document.createElement('td');
          macCell.textContent = station.mac || 'N/A';
          macCell.style.paddingLeft = '8px';
          
          clientRow.appendChild(clientLabel);
          clientRow.appendChild(macCell);
          clientTable.appendChild(clientRow);
        });
        
        // Clear and update station cell
        stationCell.innerHTML = '';
        stationCell.appendChild(clientTable);
        
        if (!existingStationRow) {
          stationRow.appendChild(stationCell);
          stationRow.style.display = isExpanded ? 'table-row' : 'none';
          existingRow.after(stationRow);
        }
        
        // Update toggle in SSID cell
        const ssidCell = existingRow.cells[0];
        let toggleSpan = ssidCell.querySelector('span');
        if (!toggleSpan) {
          toggleSpan = document.createElement('span');
          toggleSpan.style.cursor = 'pointer';
          toggleSpan.onclick = () => toggleStationsVisibility(toggleSpan, { MAC: row.MAC, stationRow });
          ssidCell.insertBefore(toggleSpan, ssidCell.firstChild);
        }
        toggleSpan.textContent = isExpanded ? '- ' : '+ ';
        
      } else if (existingStationRow) {
        // Remove station row if no longer needed
        existingStationRow.remove();
      }
      
    } else {
      // Create new row for new AP
      const apRow = document.createElement('tr');
      apRow.setAttribute('data-mac', row.MAC);
      
      // Create cells
      const cells = [
        { text: row.SSID || 'N/A' },
        { text: row.MAC || 'N/A' },
        { text: row.Security || 'N/A' },
        { text: row.Channel || 'N/A' }
      ];
      
      cells.forEach(cell => {
        const td = document.createElement('td');
        td.textContent = cell.text;
        apRow.appendChild(td);
      });
      
      tableBody.appendChild(apRow);
      
      // Add station row if needed
      if (row.stations && row.stations.length > 0) {
        const isExpanded = apExpandedStates[row.MAC] === true;
        const stationRow = document.createElement('tr');
        const stationCell = document.createElement('td');
        stationCell.colSpan = 5;
        
        const clientTable = document.createElement('table');
        clientTable.className = 'client-table';
        clientTable.style.width = '100%';
        
        row.stations.forEach(station => {
          const clientRow = document.createElement('tr');
          clientRow.className = 'client-row';
          
          const clientLabel = document.createElement('td');
          clientLabel.textContent = 'Client:';
          clientLabel.style.width = '15%';
          
          const macCell = document.createElement('td');
          macCell.textContent = station.mac || 'N/A';
          macCell.style.paddingLeft = '8px';
          
          clientRow.appendChild(clientLabel);
          clientRow.appendChild(macCell);
          clientTable.appendChild(clientRow);
        });
        
        stationCell.appendChild(clientTable);
        stationRow.appendChild(stationCell);
        stationRow.style.display = isExpanded ? 'table-row' : 'none';
        
        // Add toggle to SSID cell
        const ssidCell = apRow.cells[0];
        const toggleSpan = document.createElement('span');
        toggleSpan.textContent = isExpanded ? '- ' : '+ ';
        toggleSpan.style.cursor = 'pointer';
        toggleSpan.onclick = () => toggleStationsVisibility(toggleSpan, { MAC: row.MAC, stationRow });
        ssidCell.insertBefore(toggleSpan, ssidCell.firstChild);
        
        apRow.after(stationRow);
      }
    }
  });
  


  // Remove rows for APs that no longer exist
  existingRows.forEach(row => {
    const mac = row.getAttribute('data-mac');
    if (mac && !processedMacs.has(mac)) {
      // Remove both the AP row and its station row if it exists
      const nextRow = row.nextElementSibling;
      if (nextRow && !nextRow.hasAttribute('data-mac')) {
        nextRow.remove();
      }
      row.remove();
    }
  });
}


function clearLocalStorage() {
    localStorage.clear();
    location.reload();
}

function toggleStationsVisibility(toggleSpan, row) {
    const { MAC, stationRow, tableId } = row;
    const stateKey = tableId + MAC;
    
    if (!stationRow) {
        // If stationRow isn't provided directly, find it in the DOM
        const apRow = toggleSpan.closest('tr');
        const nextRow = apRow.nextElementSibling;
        if (nextRow && !nextRow.hasAttribute('data-mac')) {
            // This is the station row
            if (nextRow.style.display === 'none') {
                nextRow.style.display = 'table-row'; // Show the client sub-table
                toggleSpan.textContent = '- ';
                apExpandedStates[stateKey] = true;
            } else {
                nextRow.style.display = 'none'; // Hide the client sub-table
                toggleSpan.textContent = '+ ';
                apExpandedStates[stateKey] = false;
            }
        }
    } else {
        // If we have a direct reference to the station row
        if (stationRow.style.display === 'none') {
            stationRow.style.display = 'table-row'; // Show the client sub-table
            toggleSpan.textContent = '- ';
            apExpandedStates[stateKey] = true;
        } else {
            stationRow.style.display = 'none'; // Hide the client sub-table
            toggleSpan.textContent = '+ ';
            apExpandedStates[stateKey] = false;
        }
    }
}



// creates an ap row with dropdown-stations and appends it to the given table body
function createAPRowWithStations(row, tableBody, isAttackTable = false) {
    // create main ap row
    const apRow = document.createElement('tr');
    apRow.setAttribute('data-mac', row.MAC);
    
    // Only make rows in attack table selectable
    if (isAttackTable) {
        // hookup click event for selection (only for attack table)
        apRow.onclick = function() {
            toggleHighlight(apRow);
        };
    }

    // create ssid cell and add toggle if stations exist
    const tdSSID = document.createElement('td');
    if (row.stations && row.stations.length > 0) {
        const toggleSpan = document.createElement('span');
        // Use tableId to distinguish between tables for expansion state
        const tableId = isAttackTable ? 'attack_' : 'recon_';
        const stateKey = tableId + row.MAC;
        
        // if expanded, show '-' else '+'
        const isExpanded = apExpandedStates[stateKey] === true;
        toggleSpan.textContent = isExpanded ? '- ' : '+ ';
        toggleSpan.style.cursor = 'pointer';
        
        // prevent the click from also triggering the apRow's onclick (selection logic)
        toggleSpan.onclick = function(e) {
            e.stopPropagation();
            toggleStationsVisibility(toggleSpan, { MAC: row.MAC, stationRow: null, tableId: tableId });
        };
        tdSSID.appendChild(toggleSpan);
        tdSSID.appendChild(document.createTextNode(row.SSID || 'N/A'));
    } else {
        tdSSID.textContent = row.SSID || 'N/A';
    }
    apRow.appendChild(tdSSID);

    // create remaining cells: mac, security, channel, band
    const tdMac = document.createElement('td');
    tdMac.textContent = row.MAC || 'N/A';
    apRow.appendChild(tdMac);

    const tdSecurity = document.createElement('td');
    tdSecurity.textContent = row.Security || 'N/A';
    apRow.appendChild(tdSecurity);

    const tdChannel = document.createElement('td');
    tdChannel.textContent = row.Channel || 'N/A';
    apRow.appendChild(tdChannel);


    tableBody.appendChild(apRow);

    // if there are stations, create a sub-row that holds a nested client table
    if (row.stations && row.stations.length > 0) {
        const tableId = isAttackTable ? 'attack_' : 'recon_';
        const stateKey = tableId + row.MAC;
        const isExpanded = apExpandedStates[stateKey] === true;
        
        const stationRow = document.createElement('tr');
        const stationCell = document.createElement('td');
        // set colspan to match the number of columns (5 in this case)
        stationCell.colSpan = 5;
        
        // create nested client table for stations
        const clientTable = document.createElement('table');
        clientTable.className = 'client-table';
        clientTable.style.width = '100%';
        
        row.stations.forEach(station => {
            const clientRow = document.createElement('tr');
            clientRow.className = 'client-row';
            
            // Only add client selection for attack table
            if (isAttackTable) {
                clientRow.onclick = (e) => {
                    e.stopPropagation();
                    toggleClientSelection(clientRow, row.MAC, station.mac);
                };
            }
            
            // client label cell
            const clientLabel = document.createElement('td');
            clientLabel.textContent = 'Client:';
            // mac address cell for the station
            const macCell = document.createElement('td');
            macCell.textContent = station.mac || 'N/A';
            clientRow.appendChild(clientLabel);
            clientRow.appendChild(macCell);
            clientTable.appendChild(clientRow);
        });
        
        stationCell.appendChild(clientTable);
        stationRow.appendChild(stationCell);
        // use isExpanded to control dropdown visibility
        stationRow.style.display = isExpanded ? 'table-row' : 'none';
        tableBody.appendChild(stationRow);
        
        // Update the toggle function with table-specific references
        const toggleSpan = tdSSID.querySelector('span');
        if (toggleSpan) {
            toggleSpan.onclick = function(e) {
                e.stopPropagation();
                toggleStationsVisibility(toggleSpan, { MAC: row.MAC, stationRow: stationRow, tableId: tableId });
            };
        }
    }
}

// then, create a function to update the table content using the reusable function
function updateTableData(dataRows, tableBodyId, isAttackTable = false) {
    const tableBody = document.getElementById(tableBodyId);
    if (!tableBody) {
        console.error('table body not found:', tableBodyId);
        return;
    }
    tableBody.innerHTML = '';
    dataRows.forEach(function(row) {
        // the same function builds the ap row (with dropdown for stations)
        createAPRowWithStations(row, tableBody, isAttackTable);
    });
}

// for deauth table:
updateTableData(globalWifiData, 'deauthTableBody', false);

// for attacks table:
updateTableData(globalAttackData, 'wifi-attack-table-body', true);

function toggleClientSelection(clientRow, apMac, clientMac) {
    // Check if this client was already selected
    const wasSelected = clientRow.classList.contains('client-selected');
    
    if (wasSelected) {
        // If already selected, unselect it
        clientRow.classList.remove('client-selected');
        
        // Remove the client MAC from the array
        if (selectedClients[apMac]) {
            const index = selectedClients[apMac].indexOf(clientMac);
            if (index > -1) {
                selectedClients[apMac].splice(index, 1);
                
                // If no clients left, clean up
                if (selectedClients[apMac].length === 0) {
                    delete selectedClients[apMac];
                    
                    // Update AP selection
                    selectedSSID = null;
                    selectedMAC = null;
                    
                    // Remove AP highlight
                    document.querySelectorAll('.highlight').forEach(row => {
                        if (row.getAttribute('data-mac') === apMac) {
                            row.classList.remove('highlight');
                        }
                    });
                }
            }
        }
    } else {
        // New selection
        clientRow.classList.add('client-selected');
        
        // Initialize the array if it doesn't exist
        if (!selectedClients[apMac]) {
            selectedClients[apMac] = [];
            
            // Set the AP context
            const apRow = document.querySelector(`tr[data-mac="${apMac}"]`);
            if (apRow) {
                selectedSSID = apRow.cells[0].textContent.replace(/^[+-] /, '');
                selectedMAC = apMac;
                
                // Highlight the AP row
                apRow.classList.add('highlight');
            }
        }
        
        // Add the client MAC to the array if not already there
        if (!selectedClients[apMac].includes(clientMac)) {
            selectedClients[apMac].push(clientMac);
        }
    }

    // Update visibility based on whether we have any selections
    const hasSelection = Object.keys(selectedClients).length > 0;
    const directButton = document.getElementById('button10');
    directButton.style.display = hasSelection ? 'inline-block' : 'none';
    const exampleText = document.querySelector('.example-text');
    exampleText.style.display = hasSelection ? 'block' : 'none';

    updateButtonText();
    
    // Debug
    console.log('Selected clients:', JSON.stringify(selectedClients));
}

function updateButtonText() {
    const directButton = document.getElementById('button10');
    if (!directButton) return;
    
    // Check if any client is selected (client selection takes priority)
    const hasClientSelection = Object.keys(selectedClients).length > 0;
    
    if (hasClientSelection) {
        directButton.textContent = 'Deauth';
    } else if (selectedSSID && selectedMAC) {
        directButton.textContent = 'Deauth';
    }
}

// Add this to the JavaScript section:
function showWarningPopup(type) {
    const warning = type === 'scan' ? document.getElementById('scanWarning') : document.getElementById('deauthWarning');
    warning.style.display = 'block';
    
    // Reset the progress bar animation
    const progressBar = warning.querySelector('.popup-progress-bar');
    progressBar.style.animation = 'none';
    progressBar.offsetHeight; // Force reflow
    progressBar.style.animation = 'progressShrink 5s linear';
    
    // Hide after 5 seconds
    setTimeout(() => {
        warning.style.display = 'none';
    }, 5000);
}

function startScan() {
    showWarningPopup('scan');
    fetchData('deauth');
}

function renderHandshakes() {
    const container = document.getElementById('handshakeCards');
    if (!container) return;
    container.innerHTML = '';
    try {
        const raw = localStorage.getItem('handshakes');
        const arr = raw ? JSON.parse(raw) : [];
        if (arr && arr.length) {
            arr.sort((a,b)=>b.ts-a.ts);
            const item = arr[0];
            const card = document.createElement('div');
            card.className = 'card download-card';
            const left = document.createElement('div');
            const title = item.type === 'capture' ? 'Capture' : 'Handshake';
            const meta = `${item.mac} • ch ${item.channel}` + (item.type === 'handshake' && typeof item.eapol_count === 'number' ? ` • ${item.eapol_count} EAPOL` : '');
            left.innerHTML = `<h4>${title}</h4><div class='muted'>${meta} • ${new Date(item.ts).toLocaleTimeString()}</div>`;
            const link = document.createElement('a');
            link.className = 'toggle-button';
            link.textContent = 'Download';
            link.href = `/handshake.pcap?mac=${encodeURIComponent(item.mac)}&ts=${item.ts}`;
            card.appendChild(left);
            card.appendChild(link);
            container.appendChild(card);
            return;
        }
    } catch (e) {}
    const empty = document.createElement('div');
    empty.className = 'card download-card';
    empty.innerHTML = `<div><h4>No capture</h4><div class='muted'>run a capture or handshake to generate a file</div></div>`;
    container.appendChild(empty);
}

// OTA upload handlers
document.addEventListener('DOMContentLoaded', function() {
    const uploadForm = document.getElementById('otaUploadForm');
    if (uploadForm) {
        uploadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const f = document.getElementById('otaFile').files[0];
            const msg = document.getElementById('otaUploadMsg');
            if (!f) { msg.textContent = 'Select a file.'; return; }
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/ota');
            xhr.onload = function() {
                try { const j = JSON.parse(xhr.responseText); msg.textContent = j.message || 'Done'; } catch (_) { msg.textContent = xhr.status===200?'Done':'Failed'; }
            };
            xhr.onerror = function(){ msg.textContent = 'Upload failed'; };
            xhr.send(f);
            msg.textContent = 'Uploading...';
        });
    }
    const fetchForm = document.getElementById('otaFetchForm');
    if (fetchForm) {
        fetchForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const url = document.getElementById('otaUrl').value;
            const msg = document.getElementById('otaFetchMsg');
            if (!url) { msg.textContent = 'Enter a URL.'; return; }
            fetch('/ota/fetch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url })
            })
            .then(r => r.json())
            .then(j => { msg.textContent = j.message || 'Requested'; })
            .catch(() => { msg.textContent = 'Fetch failed'; });
            msg.textContent = 'Fetching...';
        });
    }
    // WiFi connect form
    const wifiForm = document.getElementById('wifiConnectForm');
    if (wifiForm) {
        wifiForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const ssid = document.getElementById('wifiSsid').value;
            const pass = document.getElementById('wifiPass').value;
            const msg = document.getElementById('wifiStatusMsg');
            if (!ssid) { msg.textContent = 'Enter SSID'; return; }
            fetch('/wifi/connect', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ssid: ssid, password: pass })
            }).then(r => r.json()).then(j => { msg.textContent = j.message || 'connecting'; })
            .catch(() => { msg.textContent = 'failed'; });
            msg.textContent = 'Connecting...';
        });
    }
    // fetch and display wifi connection status immediately and periodically
    function updateWifiBadge() {
        fetch('/wifi/status')
            .then(r => r.json())
            .then(j => {
                const pairs = [
                    {dot: 'wifiDot', text: 'wifiText'},
                    {dot: 'wifiDotInline', text: 'wifiTextInline'}
                ];
                pairs.forEach(p => {
                    const dot = document.getElementById(p.dot);
                    const txt = document.getElementById(p.text);
                    if (!dot || !txt) return;
                    if (j && j.status === 'connected') {
                        dot.style.background = '#0f0';
                        txt.textContent = 'Connected';
                    } else {
                        dot.style.background = '#a00';
                        txt.textContent = 'Disconnected';
                    }
                });
            })
            .catch(() => {
                ['wifiDot','wifiDotInline'].forEach(id => { const d = document.getElementById(id); if (d) d.style.background = '#a00'; });
                ['wifiText','wifiTextInline'].forEach(id => { const t = document.getElementById(id); if (t) t.textContent = 'Unknown'; });
            });
    }
    updateWifiBadge();
    setInterval(updateWifiBadge, 5000); // poll every 5s
});

// Smart plug control handlers
document.addEventListener('DOMContentLoaded', function() {
    const onBtn = document.getElementById('plugOnBtn');
    const offBtn = document.getElementById('plugOffBtn');
    const dot = document.getElementById('plugDot');
    const text = document.getElementById('plugText');

    function setStatus(isOn) {
        if (!dot || !text) return;
        if (isOn) {
            dot.style.background = '#0f0';
            text.textContent = 'On';
        } else {
            dot.style.background = '#a00';
            text.textContent = 'Off';
        }
    }

    function updatePlugStatus() {
        fetch('/gpio/status?pin=4')
            .then(r => r.json())
            .then(j => {
                if (j && typeof j.value !== 'undefined') {
                    setStatus(Boolean(j.value));
                }
            })
            .catch(() => {});
    }

    function sendPlug(value) {
        fetch('/gpio', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ pin: 4, value: value ? 1 : 0 })
        })
        .then(r => r.json())
        .then(j => {
            // update status from authoritative server response
            if (j && typeof j.value !== 'undefined') setStatus(Boolean(j.value));
            else setStatus(Boolean(value));
        })
        .catch(() => {
            // if request failed, refresh actual status
            setTimeout(updatePlugStatus, 200);
        });
    }

    if (onBtn) onBtn.addEventListener('click', () => sendPlug(1));
    if (offBtn) offBtn.addEventListener('click', () => sendPlug(0));

    // initial status and poll
    updatePlugStatus();
    setInterval(updatePlugStatus, 5000);
});

</script>
</body>
</html>