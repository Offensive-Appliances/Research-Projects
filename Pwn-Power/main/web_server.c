#include "esp_http_server.h"
#include "esp_log.h"
#include "http_parser.h"
#include "wifi_scan.h"
#include "index_content.h"   // This includes the header generated by the Python script
#include "cJSON.h"
#include "deauth.h"
#include "handshake.h"
#include "ota.h"
#include "esp_http_client.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_netif.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "driver/gpio.h"
// some SDK versions expose gpio_pad_select_gpio as esp_rom_gpio_pad_select_gpio
#ifndef gpio_pad_select_gpio
#define gpio_pad_select_gpio esp_rom_gpio_pad_select_gpio
#endif

#define TAG "WebServer"

#define SMARTPLUG_GPIO 4
static int s_smartplug_level = 0;
static bool s_smartplug_inited = false;

// Add missing HTTP status code if not defined
#ifndef HTTPD_503_SERVICE_UNAVAILABLE
#define HTTPD_503_SERVICE_UNAVAILABLE 503
#endif

#define MAX_HS_STA 10
typedef struct { uint8_t bssid[6]; int channel; int duration; uint8_t stas[MAX_HS_STA][6]; int sta_count; } hs_args_t;
static TaskHandle_t hs_task_handle = NULL;
static hs_args_t hs_args;

// simple STA connection helpers used by the web UI
static volatile bool g_sta_connected = false;
static bool g_ip_handler_registered = false;
static bool g_wifi_handler_registered = false;
static bool s_wifi_inited = false;

static void ip_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
    if (event_id == IP_EVENT_STA_GOT_IP) {
        g_sta_connected = true;
        ESP_LOGI(TAG, "STA got IP");
    }
}

static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
    if (event_id == WIFI_EVENT_STA_DISCONNECTED) {
        g_sta_connected = false;
        ESP_LOGI(TAG, "STA disconnected");
    }
}

static bool attempt_sta_connect(const char *ssid, const char *password,
                                wifi_auth_mode_t threshold_mode,
                                bool pmf_required,
                                uint32_t wait_ms) {
    if (!s_wifi_inited) {
        wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
        if (esp_wifi_init(&cfg) != ESP_OK) {
            ESP_LOGE(TAG, "esp_wifi_init failed");
            return false;
        }
        s_wifi_inited = true;
    }

    // ensure netif + event loop
    esp_netif_init();
    esp_event_loop_create_default();
    // avoid creating duplicate default STA netif
    if (esp_netif_get_handle_from_ifkey("WIFI_STA_DEF") == NULL) {
        esp_netif_create_default_wifi_sta();
    }

    // register handlers once
    if (!g_ip_handler_registered) {
        if (esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL) == ESP_OK) g_ip_handler_registered = true;
    }
    if (!g_wifi_handler_registered) {
        if (esp_event_handler_register(WIFI_EVENT, WIFI_EVENT_STA_DISCONNECTED, &wifi_event_handler, NULL) == ESP_OK) g_wifi_handler_registered = true;
    }

    // keep AP running while adding STA - use APSTA mode so AP continues to host
    // do not stop wifi here (that would tear down the AP)
    esp_wifi_set_mode(WIFI_MODE_APSTA);

    wifi_config_t sta_cfg = {0};
    if (ssid) strncpy((char*)sta_cfg.sta.ssid, ssid, sizeof(sta_cfg.sta.ssid));
    if (password) strncpy((char*)sta_cfg.sta.password, password, sizeof(sta_cfg.sta.password));
    sta_cfg.sta.threshold.authmode = threshold_mode;
    sta_cfg.sta.pmf_cfg.capable = true;
    sta_cfg.sta.pmf_cfg.required = pmf_required;
#ifdef WPA3_SAE_PWE_BOTH
    sta_cfg.sta.sae_pwe_h2e = WPA3_SAE_PWE_BOTH;
#endif
    esp_wifi_set_config(WIFI_IF_STA, &sta_cfg);
    esp_wifi_start();
    vTaskDelay(pdMS_TO_TICKS(100));
    esp_wifi_set_ps(WIFI_PS_NONE);

    ESP_LOGI(TAG, "Attempting STA connect ssid=\"%s\" threshold=%d pmf_required=%s wait_ms=%u", ssid, threshold_mode, pmf_required ? "true" : "false", wait_ms);

    g_sta_connected = false;
    esp_err_t e = esp_wifi_connect();
    if (e != ESP_OK) {
        ESP_LOGE(TAG, "esp_wifi_connect err=%d", e);
        return false;
    }

    uint32_t waited = 0;
    while (!g_sta_connected && waited < wait_ms) {
        vTaskDelay(pdMS_TO_TICKS(100));
        waited += 100;
    }
    return g_sta_connected;
}
static void hs_task(void *arg) {
	hs_args_t *a = (hs_args_t*)arg;
	ESP_LOGI(TAG, "hs_task start: bssid=%02X:%02X:%02X:%02X:%02X:%02X channel=%d duration=%d sta_count=%d",
			a->bssid[0], a->bssid[1], a->bssid[2], a->bssid[3], a->bssid[4], a->bssid[5], a->channel, a->duration, a->sta_count);
	vTaskDelay(pdMS_TO_TICKS(300));
	int e = 0;
	start_handshake_capture(a->bssid, a->channel, a->duration, a->stas, a->sta_count, &e);
	ESP_LOGI(TAG, "Handshake capture done: eapol=%d", e);
	hs_task_handle = NULL;
	vTaskDelete(NULL);
}

// Handler for serving the index.html content directly from the array
static esp_err_t index_handler(httpd_req_t *req) {
    // Send the index.html content from the array as a response
    httpd_resp_send(req, (const char *)INDEX_CONTENT, INDEX_CONTENT_SIZE);
    return ESP_OK;
}
// Handler for scanning Wi-Fi networks
static esp_err_t wifi_scan_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received Wi-Fi scan request");

    // check if deauth is running
    if(deauth_task_handle != NULL) {
        httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "Cannot scan during active attack");
        return ESP_FAIL;
    }

    // ALWAYS return cached results first if we have them
    const char *cached_results = wifi_scan_get_results();
    if(cached_results && strlen(cached_results) > 2) { // Check if we have valid JSON (more than just {})
        httpd_resp_set_type(req, "application/json");
        httpd_resp_send(req, cached_results, strlen(cached_results));
        
        // Only start a new scan if:
        // 1. No scan is currently in progress
        // 2. We don't have new results waiting
        if(wifi_scan_is_complete() && !wifi_scan_has_new_results()) {
            // Start scan in background AFTER sending response
            wifi_scan();
        }
        return ESP_OK;
    }

    // If we have no cached results at all, we must do an initial scan
    if(wifi_scan_is_complete()) {
        wifi_scan();
    }

    // Return empty JSON if we have nothing yet
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"rows\":[]}");
    return ESP_OK;
}

static esp_err_t startattack_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received attack command");
    
    char query_str[200] = {0};
    char mac_str[18] = {0};
    char state_str[8] = {0};
    
    // Log request type and size
    size_t query_len = httpd_req_get_url_query_len(req);
    ESP_LOGD(TAG, "Incoming request: %s, query_len=%d", 
             query_len > 0 ? "GET" : "POST", query_len);

    // First try to get URL query string
    if(query_len > 0) {
        if(httpd_req_get_url_query_str(req, query_str, sizeof(query_str)) != ESP_OK) {
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid query params");
            return ESP_FAIL;
        }
    } else {
        // check POST body
        int ret = httpd_req_recv(req, query_str, sizeof(query_str)-1);
        if(ret <= 0) {
            httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing params");
            return ESP_FAIL;
        }
        query_str[ret] = '\0';  // Null-terminate
    }
    
    // Add raw data logging
    ESP_LOGD(TAG, "Raw input: %s", query_str);

    cJSON *root = cJSON_Parse(query_str);
    if (!root) {
        ESP_LOGE(TAG, "Failed to parse JSON: %s", query_str);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    // Log extracted values
    cJSON *mac_json = cJSON_GetObjectItem(root, "mac");
    cJSON *state_json = cJSON_GetObjectItem(root, "state");
    cJSON *channel_json = cJSON_GetObjectItem(root, "channel");
    ESP_LOGI(TAG, "Parsed MAC: %s, State: %s, Channel: %s", 
            mac_json ? mac_json->valuestring : "NULL",
            state_json ? state_json->valuestring : "NULL",
            channel_json ? channel_json->valuestring : "NULL");

    if (!cJSON_IsString(mac_json) || !cJSON_IsString(state_json) || !cJSON_IsString(channel_json)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing/invalid fields");
        return ESP_FAIL;
    }

    strlcpy(mac_str, mac_json->valuestring, sizeof(mac_str));
    strlcpy(state_str, state_json->valuestring, sizeof(state_str));
    int target_channel = atoi(channel_json->valuestring);
    
    // new sta field parsing
    cJSON *sta_json = cJSON_GetObjectItem(root, "sta");
    bool has_specific_targets = false;
    
    // We'll store up to 10 target stations
    #define MAX_TARGET_STATIONS 10
    uint8_t target_stas[MAX_TARGET_STATIONS][6];
    int target_sta_count = 0;
    
    // First clear all entries
    memset(target_stas, 0, sizeof(target_stas));

    if (sta_json) {
        // Check if it's a string (single MAC) or an array (multiple MACs)
        if (cJSON_IsString(sta_json)) {
            // Single MAC address
            sscanf(sta_json->valuestring, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
                &target_stas[0][0], &target_stas[0][1], &target_stas[0][2],
                &target_stas[0][3], &target_stas[0][4], &target_stas[0][5]);
            target_sta_count = 1;
            has_specific_targets = true;
            ESP_LOGI(TAG, "Single target client: %s", sta_json->valuestring);
        } 
        else if (cJSON_IsArray(sta_json)) {
            // Array of MAC addresses
            int size = cJSON_GetArraySize(sta_json);
            ESP_LOGI(TAG, "Found %d target clients", size);
            
            for (int i = 0; i < size && i < MAX_TARGET_STATIONS; i++) {
                cJSON *item = cJSON_GetArrayItem(sta_json, i);
                if (cJSON_IsString(item)) {
                    int converted = sscanf(item->valuestring, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
                        &target_stas[i][0], &target_stas[i][1], &target_stas[i][2],
                        &target_stas[i][3], &target_stas[i][4], &target_stas[i][5]);
                    
                    if (converted == 6) {
                        // Check if this MAC is the same as the AP MAC - can't deauth yourself
                        if (mac_json && item->valuestring && strcmp(item->valuestring, mac_json->valuestring) == 0) {
                            ESP_LOGW(TAG, "Ignoring client MAC that matches AP MAC: %s", item->valuestring);
                        } else {
                            target_sta_count++;
                            has_specific_targets = true;
                            ESP_LOGI(TAG, "Target client %d: %s", i, item->valuestring);
                        }
                    } else {
                        ESP_LOGE(TAG, "Invalid MAC format for client %d: %s", i, item->valuestring);
                    }
                }
            }
        }
    }

    cJSON_Delete(root);

    // Log MAC conversion attempt
    ESP_LOGD(TAG, "Converting MAC: %s", mac_str);
    uint8_t target_bssid[6];
    int mac_conversion = sscanf(mac_str, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
        &target_bssid[0], &target_bssid[1], &target_bssid[2],
        &target_bssid[3], &target_bssid[4], &target_bssid[5]);
    
    if(mac_conversion != 6) {
        ESP_LOGE(TAG, "Invalid MAC format: %s (converted %d/6 octets)", mac_str, mac_conversion);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Bad MAC");
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "Converted BSSID: %02X:%02X:%02X:%02X:%02X:%02X",
             target_bssid[0], target_bssid[1], target_bssid[2], target_bssid[3],
             target_bssid[4], target_bssid[5]);

    // 5Ghz: if(target_channel < 1 || target_channel > 165) {
    // 2.4Ghz: if(target_channel < 1 || target_channel > 14) {
    if(target_channel < 1 || target_channel > 165) {
        ESP_LOGE(TAG, "Invalid channel number: %d", target_channel);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid channel");
        return ESP_FAIL;
    }

    if(memcmp(target_bssid, "\xFF\xFF\xFF\xFF\xFF\xFF", 6) == 0) {
        ESP_LOGE(TAG, "Attempted broadcast DEAUTH attack!");
        httpd_resp_send_err(req, HTTPD_403_FORBIDDEN, "Broadcast not allowed");
        return ESP_FAIL;
    }

    // Log attack state change
    if(strcmp(state_str, "started") == 0) {
        if(!has_specific_targets) {
            // no sta provided - scan and attack all + broadcast
            wifi_scan_stations();
            const char *station_json = wifi_scan_get_station_results();
            cJSON *root = cJSON_Parse(station_json);
            
            // FIND AP'S STATIONS
            char ap_mac_str[18];
            snprintf(ap_mac_str, sizeof(ap_mac_str), "%02X:%02X:%02X:%02X:%02X:%02X",
                    target_bssid[0], target_bssid[1], target_bssid[2],
                    target_bssid[3], target_bssid[4], target_bssid[5]);
            
            cJSON *ap_entry = cJSON_GetObjectItemCaseSensitive(root, ap_mac_str);
            if(ap_entry) {
                cJSON *stations = cJSON_GetObjectItem(ap_entry, "stations");
                cJSON *station;
                cJSON_ArrayForEach(station, stations) {
                    // ADD TARGETED ATTACK FOR EACH STA
                    cJSON *sta_mac_json = cJSON_GetObjectItem(station, "mac");
                    uint8_t sta_mac[6];
                    sscanf(sta_mac_json->valuestring, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
                        &sta_mac[0], &sta_mac[1], &sta_mac[2],
                        &sta_mac[3], &sta_mac[4], &sta_mac[5]);
                        
                    wifi_manager_start_deauth(target_bssid, target_channel, sta_mac);
                }
            }
            // ADD BROADCAST ATTACK
            wifi_manager_start_deauth(target_bssid, target_channel, NULL);
            cJSON_Delete(root);
        } else {
            // direct targeted attack to specific clients + broadcast
            for (int i = 0; i < target_sta_count; i++) {
                // Skip if client MAC matches AP MAC - can't deauth yourself
                if (memcmp(target_stas[i], target_bssid, 6) == 0) {
                    ESP_LOGW(TAG, "Skipping client that matches AP MAC: %02X:%02X:%02X:%02X:%02X:%02X", 
                        target_stas[i][0], target_stas[i][1], target_stas[i][2],
                        target_stas[i][3], target_stas[i][4], target_stas[i][5]);
                    continue;
                }
                
                ESP_LOGI(TAG, "Sending deauth to client %d: %02X:%02X:%02X:%02X:%02X:%02X", 
                    i, target_stas[i][0], target_stas[i][1], target_stas[i][2],
                    target_stas[i][3], target_stas[i][4], target_stas[i][5]);
                    
                wifi_manager_start_deauth(target_bssid, target_channel, target_stas[i]);
            }
            // Also add broadcast attack
            wifi_manager_start_deauth(target_bssid, target_channel, NULL);
        }
    } else if(strcmp(state_str, "stopped") == 0) {
        ESP_LOGI(TAG, "STOPPING attack on %s", mac_str);
        wifi_manager_stop_deauth(target_bssid);
    } else {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid state");
        return ESP_FAIL;
    }

    ESP_LOGI(TAG, "Attack command processed successfully");
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"success\"}");
    return ESP_OK;
}


static esp_err_t station_scan_handler(httpd_req_t *req) {
    if(deauth_task_handle != NULL) {
        httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "scan blocked during attack");
        return ESP_FAIL;
    }
    
    wifi_scan_stations();
    const char *json = wifi_scan_get_station_results();
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json, strlen(json));
    return ESP_OK;
}

// New handler that ONLY returns cached results without triggering a scan
static esp_err_t cached_scan_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received cached-only scan request");
    
    // Return cached results if we have them
    const char *cached_results = wifi_scan_get_results();
    if(cached_results && strlen(cached_results) > 2) { // Check if we have valid JSON (more than just {})
        httpd_resp_set_type(req, "application/json");
        httpd_resp_send(req, cached_results, strlen(cached_results));
        return ESP_OK;
    }
    
    // Return empty JSON if we have no cached results
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"rows\":[]}");
    return ESP_OK;
}

static esp_err_t handshake_handler(httpd_req_t *req) {
    if(deauth_task_handle != NULL) {
        httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "attack in progress");
        return ESP_FAIL;
    }

    char body[256] = {0};
    int ret = httpd_req_recv(req, body, sizeof(body)-1);
    if(ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing body");
        return ESP_FAIL;
    }
    body[ret] = '\0';
    ESP_LOGI(TAG, "Handshake request body: %s", body);

    cJSON *root = cJSON_Parse(body);
    if(!root) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
        return ESP_FAIL;
    }

    cJSON *mac_json = cJSON_GetObjectItem(root, "mac");
    cJSON *channel_json = cJSON_GetObjectItem(root, "channel");
    cJSON *duration_json = cJSON_GetObjectItem(root, "duration");
    cJSON *sta_json = cJSON_GetObjectItem(root, "sta");
    if(!cJSON_IsString(mac_json) || !cJSON_IsString(channel_json) || !cJSON_IsNumber(duration_json)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing fields");
        return ESP_FAIL;
    }

    uint8_t bssid[6];
    if(sscanf(mac_json->valuestring, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &bssid[0], &bssid[1], &bssid[2], &bssid[3], &bssid[4], &bssid[5]) != 6) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad mac");
        return ESP_FAIL;
    }

    int channel = atoi(channel_json->valuestring);
    int duration = duration_json->valueint;
    if(channel < 1 || channel > 165 || duration <= 0) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad params");
        return ESP_FAIL;
    }

    uint8_t stas[MAX_HS_STA][6];
    int sta_count = 0;
    memset(stas, 0, sizeof(stas));
    if(sta_json) {
        if(cJSON_IsString(sta_json)) {
            if(sscanf(sta_json->valuestring, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &stas[0][0], &stas[0][1], &stas[0][2], &stas[0][3], &stas[0][4], &stas[0][5]) == 6) {
                sta_count = 1;
            }
        } else if(cJSON_IsArray(sta_json)) {
            int n = cJSON_GetArraySize(sta_json);
            for(int i=0;i<n && i<MAX_HS_STA;i++) {
                cJSON *it = cJSON_GetArrayItem(sta_json, i);
                if(cJSON_IsString(it)) {
                    if(sscanf(it->valuestring, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &stas[i][0], &stas[i][1], &stas[i][2], &stas[i][3], &stas[i][4], &stas[i][5]) == 6) {
                        sta_count++;
                    }
                }
            }
        }
    }

    if(hs_task_handle != NULL) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "handshake busy");
        return ESP_FAIL;
    }
    memcpy(hs_args.bssid, bssid, 6);
    hs_args.channel = channel;
    hs_args.duration = duration;
    memcpy(hs_args.stas, stas, sizeof(stas));
    hs_args.sta_count = sta_count;
    ESP_LOGI(TAG, "Handshake capture start: bssid=%s, channel=%d, duration=%d, sta_count=%d", mac_json->valuestring, channel, duration, sta_count);
    cJSON *res = cJSON_CreateObject();
    cJSON_AddStringToObject(res, "status", "started");
    char *out = cJSON_PrintUnformatted(res);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    cJSON_free(out);
    cJSON_Delete(res);
    ESP_LOGI(TAG, "Handshake response sent, starting capture task");
    cJSON_Delete(root);
    xTaskCreate(hs_task, "hs_task", 4096, &hs_args, 5, &hs_task_handle);
    return ESP_OK;
}

static esp_err_t handshake_pcap_handler(httpd_req_t *req) {
    size_t sz = 0;
    const uint8_t *data = handshake_pcap_data(&sz);
    if(sz == 0) {
        ESP_LOGW(TAG, "PCAP requested but empty");
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "no pcap");
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "PCAP request size=%u", (unsigned)sz);
    httpd_resp_set_type(req, "application/vnd.tcpdump.pcap");
    char disp[64];
    snprintf(disp, sizeof(disp), "attachment; filename=\"%s\"", handshake_pcap_filename());
    httpd_resp_set_hdr(req, "Content-Disposition", disp);
    httpd_resp_send(req, (const char*)data, sz);
    return ESP_OK;
}

static esp_err_t ota_upload_handler(httpd_req_t *req) {
	if(deauth_task_handle != NULL) {
		httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "Cannot update during active attack");
		return ESP_FAIL;
	}
	if(hs_task_handle != NULL) {
		httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "Cannot update during handshake capture");
		return ESP_FAIL;
	}

	ESP_LOGI(TAG, "OTA upload start, len=%d", (int)req->content_len);

	esp_ota_handle_t handle = 0;
	const esp_partition_t *part = NULL;
	if (ota_begin(req->content_len, &handle, &part) != ESP_OK) {
		// begin failed, probably no ota partition
		ESP_LOGE(TAG, "ota begin failed");
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA begin failed (no OTA partition?)");
		return ESP_FAIL;
	}

	char *buf = malloc(4096);
	if (!buf) {
		ESP_LOGE(TAG, "malloc failed");
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "malloc failed");
		return ESP_FAIL;
	}

	size_t remaining = req->content_len;
	while (remaining > 0) {
		int to_read = remaining > 4096 ? 4096 : (int)remaining;
		int r = httpd_req_recv(req, buf, to_read);
		if (r <= 0) {
			ESP_LOGE(TAG, "recv failed r=%d", r);
			free(buf);
			httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Receive failed");
			return ESP_FAIL;
		}
		if (ota_write(handle, buf, (size_t)r) != ESP_OK) {
			ESP_LOGE(TAG, "ota write failed");
			free(buf);
			httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA write failed");
			return ESP_FAIL;
		}
		remaining -= (size_t)r;
	}

	if (ota_finish_and_set_boot(handle, part) != ESP_OK) {
		free(buf);
		ESP_LOGE(TAG, "ota finish failed");
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA finish failed");
		return ESP_FAIL;
	}

	ESP_LOGI(TAG, "OTA upload complete, rebooting soon");
	httpd_resp_set_type(req, "application/json");
	httpd_resp_sendstr(req, "{\"status\":\"ok\",\"message\":\"Firmware uploaded. Rebooting in 3 seconds...\"}");
	free(buf);
	ota_schedule_reboot_ms(3000);
	return ESP_OK;
}

static esp_err_t ota_fetch_handler(httpd_req_t *req) {
	char body[256] = {0};
	int ret = httpd_req_recv(req, body, sizeof(body)-1);
	if (ret <= 0) {
		httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing body");
		return ESP_FAIL;
	}
	body[ret] = '\0';
	cJSON *root = cJSON_Parse(body);
	if (!root) {
		httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
		return ESP_FAIL;
	}
	cJSON *urlj = cJSON_GetObjectItem(root, "url");
	if (!cJSON_IsString(urlj)) {
		cJSON_Delete(root);
		httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing url");
		return ESP_FAIL;
	}

	ESP_LOGI(TAG, "OTA fetch: %s", urlj->valuestring);

	esp_ota_handle_t handle = 0;
	const esp_partition_t *part = NULL;
	if (ota_begin(0, &handle, &part) != ESP_OK) {
		cJSON_Delete(root);
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA begin failed");
		return ESP_FAIL;
	}

	esp_http_client_config_t cfg = { .url = urlj->valuestring, .timeout_ms = 10000 };
	esp_http_client_handle_t client = esp_http_client_init(&cfg);
	if (!client) {
		cJSON_Delete(root);
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "client init failed");
		return ESP_FAIL;
	}
	esp_err_t err = esp_http_client_open(client, 0);
	if (err != ESP_OK) {
		esp_http_client_cleanup(client);
		cJSON_Delete(root);
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "open failed");
		return ESP_FAIL;
	}

	char *buf = malloc(4096);
	if (!buf) {
		esp_http_client_close(client);
		esp_http_client_cleanup(client);
		cJSON_Delete(root);
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "malloc failed");
		return ESP_FAIL;
	}
	while (1) {
		int r = esp_http_client_read(client, buf, 4096);
		if (r < 0) { err = ESP_FAIL; break; }
		if (r == 0) break;
		if (ota_write(handle, buf, (size_t)r) != ESP_OK) { err = ESP_FAIL; break; }
	}
	free(buf);
	esp_http_client_close(client);
	esp_http_client_cleanup(client);
	cJSON_Delete(root);

	if (err != ESP_OK) {
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "download failed");
		return ESP_FAIL;
	}
	if (ota_finish_and_set_boot(handle, part) != ESP_OK) {
		httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "OTA finish failed");
		return ESP_FAIL;
	}
	httpd_resp_set_type(req, "application/json");
	httpd_resp_sendstr(req, "{\"status\":\"ok\",\"message\":\"Update downloaded. Rebooting...\"}");
	ota_schedule_reboot_ms(3000);
	return ESP_OK;
}

httpd_uri_t uri_get = {
    .uri = "/",
    .method = HTTP_GET,
    .handler = index_handler,
    .user_ctx = NULL
};

httpd_uri_t uri_scan = {
    .uri = "/scan",
    .method = HTTP_GET,
    .handler = wifi_scan_handler,
    .user_ctx = NULL
};

httpd_uri_t uri_cached_scan = {
    .uri = "/cached-scan",
    .method = HTTP_GET,
    .handler = cached_scan_handler,
    .user_ctx = NULL
};

httpd_uri_t uri_attack = {
    .uri = "/start-attack",
    .method = HTTP_POST,
    .handler = startattack_handler,
    .user_ctx = NULL
};

httpd_uri_t uri_stations = {
    .uri = "/scan-stations",
    .method = HTTP_GET,
    .handler = station_scan_handler
};

httpd_uri_t uri_handshake = {
    .uri = "/handshake-capture",
    .method = HTTP_POST,
    .handler = handshake_handler,
    .user_ctx = NULL
};

typedef struct { int channel; int duration; } gc_args_t;
static void gc_task(void *arg) {
    gc_args_t *a = (gc_args_t*)arg;
    vTaskDelay(pdMS_TO_TICKS(200));
    start_general_capture(a->channel, a->duration);
    vTaskDelete(NULL);
}

static esp_err_t general_capture_handler(httpd_req_t *req) {
    if(deauth_task_handle != NULL) {
        httpd_resp_send_err(req, HTTPD_503_SERVICE_UNAVAILABLE, "attack in progress");
        return ESP_FAIL;
    }
    char body[128] = {0};
    int ret = httpd_req_recv(req, body, sizeof(body)-1);
    if(ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing body");
        return ESP_FAIL;
    }
    body[ret] = '\0';
    cJSON *root = cJSON_Parse(body);
    if(!root) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
        return ESP_FAIL;
    }
    cJSON *channel_json = cJSON_GetObjectItem(root, "channel");
    cJSON *duration_json = cJSON_GetObjectItem(root, "duration");
    if(!cJSON_IsString(channel_json) || !cJSON_IsNumber(duration_json)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing fields");
        return ESP_FAIL;
    }
    int channel = atoi(channel_json->valuestring);
    int duration = duration_json->valueint;
    if(channel < 1 || channel > 165 || duration <= 0) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad params");
        return ESP_FAIL;
    }
    cJSON_Delete(root);
    TaskHandle_t gc_task_handle = NULL;
    typedef struct { int channel; int duration; } gc_args_t;
    static gc_args_t gc_args;
    gc_args.channel = channel;
    gc_args.duration = duration;
    cJSON *res = cJSON_CreateObject();
    cJSON_AddStringToObject(res, "status", "started");
    char *out = cJSON_PrintUnformatted(res);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    cJSON_free(out);
    cJSON_Delete(res);
    xTaskCreate(gc_task, "gc_task", 4096, &gc_args, 5, &gc_task_handle);
    return ESP_OK;
}

httpd_uri_t uri_hs_pcap = {
    .uri = "/handshake.pcap",
    .method = HTTP_GET,
    .handler = handshake_pcap_handler,
    .user_ctx = NULL
};

httpd_uri_t uri_general_capture = {
    .uri = "/capture",
    .method = HTTP_POST,
    .handler = general_capture_handler,
    .user_ctx = NULL
};

httpd_uri_t uri_ota = {
	.uri = "/ota",
	.method = HTTP_POST,
	.handler = ota_upload_handler,
	.user_ctx = NULL
};

httpd_uri_t uri_ota_fetch = {
	.uri = "/ota/fetch",
	.method = HTTP_POST,
	.handler = ota_fetch_handler,
	.user_ctx = NULL
};

static esp_err_t wifi_connect_handler(httpd_req_t *req) {
    char buf[256] = {0};
    int ret = httpd_req_recv(req, buf, sizeof(buf)-1);
    if (ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing body");
        return ESP_FAIL;
    }
    buf[ret] = '\0';
    cJSON *root = cJSON_Parse(buf);
    if (!root) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
        return ESP_FAIL;
    }
    cJSON *ssid = cJSON_GetObjectItem(root, "ssid");
    cJSON *pass = cJSON_GetObjectItem(root, "password");
    if (!cJSON_IsString(ssid)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing ssid");
        return ESP_FAIL;
    }

    // attempt to connect and wait up to 10s for IP
    bool ok = attempt_sta_connect(ssid->valuestring, cJSON_IsString(pass) ? pass->valuestring : NULL,
            WIFI_AUTH_WPA2_PSK, false, 10000);
    cJSON_Delete(root);

    cJSON *res = cJSON_CreateObject();
    if (ok) cJSON_AddStringToObject(res, "message", "connected");
    else cJSON_AddStringToObject(res, "message", "connect failed");
    char *out = cJSON_PrintUnformatted(res);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    cJSON_free(out);
    cJSON_Delete(res);
    return ESP_OK;
}

// handler to report STA connection status
static esp_err_t wifi_status_handler(httpd_req_t *req) {
    cJSON *res = cJSON_CreateObject();
    if (g_sta_connected) {
        cJSON_AddStringToObject(res, "status", "connected");
    } else {
        cJSON_AddStringToObject(res, "status", "disconnected");
    }
    char *out = cJSON_PrintUnformatted(res);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    cJSON_free(out);
    cJSON_Delete(res);
    return ESP_OK;
}

// Handler to set GPIO value for smart plug
static esp_err_t gpio_set_handler(httpd_req_t *req) {
    char body[128] = {0};
    int ret = httpd_req_recv(req, body, sizeof(body)-1);
    if (ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing body");
        return ESP_FAIL;
    }
    body[ret] = '\0';
    cJSON *root = cJSON_Parse(body);
    if (!root) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "bad json");
        return ESP_FAIL;
    }
    cJSON *pinj = cJSON_GetObjectItem(root, "pin");
    cJSON *valj = cJSON_GetObjectItem(root, "value");
    if (!cJSON_IsNumber(pinj) || !cJSON_IsNumber(valj)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "missing fields");
        return ESP_FAIL;
    }
    int pin = pinj->valueint;
    int val = valj->valueint ? 1 : 0;
    cJSON_Delete(root);

    if (pin != SMARTPLUG_GPIO) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "invalid pin");
        return ESP_FAIL;
    }

    // init once
    if (!s_smartplug_inited) {
        gpio_pad_select_gpio(pin);
        gpio_set_direction(pin, GPIO_MODE_OUTPUT);
        s_smartplug_inited = true;
    }
    gpio_set_level(pin, val);
    s_smartplug_level = val;

    cJSON *res = cJSON_CreateObject();
    cJSON_AddStringToObject(res, "status", "ok");
    cJSON_AddNumberToObject(res, "value", s_smartplug_level);
    char *out = cJSON_PrintUnformatted(res);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    cJSON_free(out);
    cJSON_Delete(res);
    return ESP_OK;
}

// Handler to get GPIO status for smart plug
static esp_err_t gpio_status_handler(httpd_req_t *req) {
    char buf[32];
    const char *pin_q = httpd_req_get_url_query_str(req, buf, sizeof(buf)) == ESP_OK ? buf : NULL;
    int pin = SMARTPLUG_GPIO;
    if (pin_q) {
        // parse pin param if provided
        char *p = strstr(pin_q, "pin=");
        if (p) pin = atoi(p+4);
    }

    if (pin != SMARTPLUG_GPIO) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "invalid pin");
        return ESP_FAIL;
    }

    // report last set level; initialize if not yet
    if (!s_smartplug_inited) {
        gpio_pad_select_gpio(pin);
        gpio_set_direction(pin, GPIO_MODE_OUTPUT);
        gpio_set_level(pin, s_smartplug_level);
        s_smartplug_inited = true;
    }
    int level = s_smartplug_level;

    cJSON *res = cJSON_CreateObject();
    cJSON_AddNumberToObject(res, "pin", pin);
    cJSON_AddNumberToObject(res, "value", level);
    char *out = cJSON_PrintUnformatted(res);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, out);
    cJSON_free(out);
    cJSON_Delete(res);
    return ESP_OK;
}

httpd_uri_t uri_wifi_status = {
    .uri = "/wifi/status",
    .method = HTTP_GET,
    .handler = wifi_status_handler,
    .user_ctx = NULL
};


// Start the web server and register URI handlers
httpd_handle_t start_webserver(void) {
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    /* increase available URI handler slots to allow additional routes (OTA, fetch, etc) */
    config.max_uri_handlers = 16;
    httpd_handle_t server = NULL;

    if (httpd_start(&server, &config) == ESP_OK) {
        httpd_register_uri_handler(server, &uri_get);
        httpd_register_uri_handler(server, &uri_scan);
        httpd_register_uri_handler(server, &uri_cached_scan);
        httpd_register_uri_handler(server, &uri_attack);
        httpd_register_uri_handler(server, &uri_stations);
        httpd_register_uri_handler(server, &uri_handshake);
        httpd_register_uri_handler(server, &uri_hs_pcap);
        httpd_register_uri_handler(server, &uri_general_capture);
        httpd_register_uri_handler(server, &uri_ota);
        httpd_register_uri_handler(server, &uri_ota_fetch);
        // register wifi status endpoint
        httpd_register_uri_handler(server, &uri_wifi_status);
        // register gpio endpoints for smart plug
        httpd_uri_t uri_gpio_set = {
            .uri = "/gpio",
            .method = HTTP_POST,
            .handler = gpio_set_handler,
            .user_ctx = NULL
        };
        httpd_uri_t uri_gpio_status = {
            .uri = "/gpio/status",
            .method = HTTP_GET,
            .handler = gpio_status_handler,
            .user_ctx = NULL
        };
        httpd_register_uri_handler(server, &uri_gpio_set);
        httpd_register_uri_handler(server, &uri_gpio_status);
        // wifi connect endpoint for providing internet during OTA
        httpd_uri_t uri_wifi_connect = {
            .uri = "/wifi/connect",
            .method = HTTP_POST,
            .handler = wifi_connect_handler,
            .user_ctx = NULL
        };
        httpd_register_uri_handler(server, &uri_wifi_connect);
        ESP_LOGI(TAG, "Web Server started");
    } else {
        ESP_LOGE(TAG, "Failed to start web server");
    }

    return server;
}
